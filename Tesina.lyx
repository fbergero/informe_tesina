#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}
\usepackage[cm]{fullpage}
\usepackage{listings}
\lstset{language=c++, xleftmargin=25pt}
\input{listings-modelica.cfg}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package \usepackage[spanish]{babel}
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Causalización
\end_layout

\begin_layout Enumerate
Conversión de un conjunto de ecuaciones diferenciales algebraicas en un
 conjunto de ecuaciones diferenciales ordinarias.
\end_layout

\begin_layout Enumerate
Ordenación horizontal y vertical de un conjunto de ecuaciones diferenciales
 algebraicas de manera que ninguna variable sea utilizada antes de que su
 valor sea computado.
\end_layout

\begin_layout Plain Layout
Ambas se pueden considerar definiciones de Causalización? Cual es la relación
 entre un conjunto de ecuaciones diferenciales ordinarias y un conjunto
 de ecuaciones ordenado de manera tal que ninguna variable sea utilizada
 (aparezca en una ecuación) antes de que su valor sea computado.
\end_layout

\begin_layout Plain Layout
Para muchos sistemas físicos es muy fácil formular un modelo donde las derivadas
 de los estados (state derivatives) aparecen implícitas o incluso de manera
 no linear en cualquier parte de una ecuación.
 A las descripciones de sistemas que consisten en un mix de ecuaciones algebraic
as implícitas y ecuaciones diferenciales las denominamos ecuaciones diferenciale
s algebraicas.
\end_layout

\begin_layout Plain Layout
El algoritmo de causalización por medio del despeje simbólico despeja las
 derivadas de los estados...
 O sea que separa las derivadas de los estados del resto de la ecuación.
 Al hacer esto la ecuación pasa de ser DAE a ODE?
\end_layout

\begin_layout Plain Layout
La ordenación vertical es lo que determina, ayuda a decidir, que variable
 despejar en cada ecuación.
\end_layout

\begin_layout Plain Layout
Por lo tanto por medio de la ordenación vertical determinamos que variable
 debe despejarse de que ecuación y luego por medio de la ordenación horizontal
 se despeja la variable que se 
\begin_inset Quotes eld
\end_inset

selecciono
\begin_inset Quotes erd
\end_inset

 para cada ecuación.
 De esta manera el sistema DAE pasa a ser uno ODE.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
State-Space Model
\end_layout

\begin_layout Plain Layout
Una representación de espacios de estados es un modelo matemático de un
 sistema físico descrito mediante un conjunto de entradas, salidas y variables
 de estado relacionadas por ecuaciones diferenciales de primer orden que
 se combinan en una ecuación diferencial matricial de primer orden
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introducción
\end_layout

\begin_layout Standard
En el contexto del proyecto 
\begin_inset Quotes eld
\end_inset

Modelado, Simulación y Control en Tiempo Real con Aplicaciones en Electrónica
 de Potencia
\begin_inset Quotes erd
\end_inset

 de la Universidad Nacional de Rosario se esta desarrollando un compilador
 para el lenguaje de modelado Modelica 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
 En este trabajo se describe la implementación de un componente de dicho
 compilador cuya tarea es la causalización de ecuaciones diferenciales algebraic
as.
\end_layout

\begin_layout Standard
Modelica es un lenguaje orientado a objetos, para el modelado de sistemas
 complejos, con componentes, mecánicos, eléctricos, electrónicos, hidráulicos,
 térmicos, etc.
 El lenguaje no tiene restricciones de uso 
\begin_inset Foot
status open

\begin_layout Plain Layout
Licencia Modelica V2
\end_layout

\end_inset

 y es desarrollado por la asociación sin fines de lucro Modelica Association.
\end_layout

\begin_layout Standard
El modelado de sistemas físicos por medio de lenguajes orientados a objetos
 conduce a descripciones constituidas por ecuaciones diferenciales algebraicas,
 o de manera abreviada descripciones DAE
\begin_inset Foot
status open

\begin_layout Plain Layout
Differential algebraic equation
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06,elmqvist2005,Fritzson98"

\end_inset

.
 Aunque esto es muy útil para el modelador la mayoría de los métodos de
 integración numérica esperan un modelo en forma de ecuación diferencial
 ordinaria o descripción ODE
\begin_inset Foot
status open

\begin_layout Plain Layout
Ordinary differential equation
\end_layout

\end_inset

.
 La conversión de un conjunto de DAEs en ODEs es lo que denominamos causalizació
n 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Esto es exáctamente así?
\end_layout

\end_inset

 de ecuaciones.
 Dependiendo de las características de cada modelo se pueden aplicar distintos
 algoritmos para convertir descripciones DAE en descripciones ODE.
 En los casos más simples la conversión se puede realizar aplicando simples
 algoritmos de ordenación, pero en otros casos, en donde se presentan grandes
 bucles algebraicos o singularidades estructurales, es necesario aplicar
 otras técnicas más complejas.
\end_layout

\begin_layout Standard
En nuestro caso para convertir ecuaciones DAE en ecuaciones ODE utilizamos
 un algoritmo de grafos que se conoce como 
\begin_inset Quotes eld
\end_inset

El algoritmo de Tarjan
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
 Para aplicar dicho algoritmo es necesario construir un grafo a partir de
 las ecuaciones suponiendo que las ecuaciones y las variables son nodos
 y las aristas representan el uso de una variable en una ecuación.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Un párrafo para cada capítulo
\end_layout

\end_inset


\end_layout

\begin_layout Section
Modelado y simulación
\end_layout

\begin_layout Standard
Se dice que las computadoras estan revolucionando la ciencia y la ingeniería.
 Utilizando computadores podemos construir complejos diseños ingenieriles
 como por ejemplo el de un transbordador espacial.
 Somos capaces the calcular las propiedades del universo tal como fueron
 fracciones de segundos después del big bang.
 Nuestras ambiciones incluso estan creciendo.
 Queremos crear diseños más complejos como mejores naves espaciales, autos,
 medicinas, sistemas de telefonía celular computarizados, etc.
 Queremos entender aspectos más profundos de la naturaleza.
 Estos son solo algunos ejemplos de modelado y simulación soportado por
 computadoras.
 Son necesarias herrimientas y conceptos más poderosos para ayudar a manejar
 tal nivel de complejidad.
 El trabajo realizado en esta tesina se enmarca en el desarrollo de una
 herramienta de estas características.
\end_layout

\begin_layout Subsection
Sistemas y experimentos
\end_layout

\begin_layout Standard
¿Que es un sistema? Ya hemos mencionado algunos sistemas como el universo
 o un transbordador espacial.
 Un sistema puede ser casi cualquier cosa.
 Un sistema puede tener subsistemas que son a su vez sistemas.
 Una definición posible de un sistema puede ser:
\end_layout

\begin_layout Itemize
Un sistema es un objecto o una colección de objetos cuyas propiedades queremos
 estudiar.
\end_layout

\begin_layout Standard
¿Que razones se pueden tener para estudiar un sistema? Esta pregunte puede
 tener muchas respuestas pero podemos destacar dos motivaciones principales:
\end_layout

\begin_layout Itemize
Estudiar un sistema para entenderlo y así poder construirlo.
 Este es el punto de vista de la ingeniería.
\end_layout

\begin_layout Itemize
Satisfacer la curiosidad humana, por ejemplo para saber más acerca de la
 naturaleza.
 Este es el punto de vista de las ciencias naturales.
\end_layout

\begin_layout Standard
Una propiedad importante de los sistemas es que deben ser observables.
 Algunos sistemas también son controlables en el sentido de que se puede
 influenciar su comportamiento suministrando valores de entrada, esto es:
\end_layout

\begin_layout Itemize
Las entradas son variables del entorno que influencian el comportamiento
 del sistema.
 Estas entradas pueden o no ser controlables por nosotros.
\end_layout

\begin_layout Itemize
Las salidas de un sistema son variables que son determinadas por el sistema
 y pueden influenciar el entorno que lo rodea.
\end_layout

\begin_layout Standard
En algunos sistemas las mismas variables actuan como entradas y salidas.
 Hablamos de comportamiento acausal si las relaciones o influencias entre
 las variables no poseen una dirección causal, como es el caso de las relaciones
 descriptas por ecuaciones.
 Por ejemplo, en un sistema mecánico las fuerzas del entorno influencian
 el desplazamiento de un objeto, pero por otro lado el desplazamiento del
 objeto influencia las fuerzas entre el objeto y el entorno.
 Que se considera como entrada y que como salida es una decision del observador,
 basado en lo que quiere estudiar, más que una propiedad del sistema.
\end_layout

\begin_layout Standard
La observabilidad es esencial para poder estudiar un sistema de acuerdo
 con nuestra definición de sistema.
 Al menos debemos poder observar algunas salidas de un sistema.
 Vamos a aprender aún más si podemos ejercitar el sistema controlando las
 entradas.
 Este proceso se llama experimentación:
\end_layout

\begin_layout Itemize
Un experimento es el proceso de extraer información de un sistema ejercitando
 sus entradas.
\end_layout

\begin_layout Standard
Una desventaja del método experimental es que para un gran número de sistemas
 muchas variables de entrada no son accesibles ni controlables.
 Estos sistemas se encuentran bajo la influencia de entradas inaccesibles
 denominadas entradas de perturbación
\begin_inset Foot
status open

\begin_layout Plain Layout
perturbance inputs
\end_layout

\end_inset

.
 Asimismo también ocurre que algunas variables de salida importantes no
 resultan accesibles para poder medirlas; estas variables a veces se denominan
 estados internos del sistema.
 Además existen una serie de problemas prácticos relacionados con la realización
 de un experimento, a saber:
\end_layout

\begin_layout Itemize
El experimento puede ser muy caro.
\end_layout

\begin_layout Itemize
El experimento puede ser muy peligroso.
\end_layout

\begin_layout Itemize
El sistema necesario para el experimento puede que todavia no exista.
 Esto es típico de sistemas que deben ser diseñados o fabricados.
\end_layout

\begin_layout Standard
Las desventajas del método experimental nos llevan al concepto de modelo.
 Si construimos un modelo del sistema, este modelo puede ser investigado
 y puede servir para responder muchas preguntas sobre el sistema real si
 el modelo es lo suficientemente realistico.
\end_layout

\begin_layout Subsection
Modelo
\end_layout

\begin_layout Standard
Dadas las definiciones previas de sistema y experimento podemos ahora intentar
 definir la noción de modelo:
\end_layout

\begin_layout Itemize
Un modelo de un sistema es cualquier cosa sobre la cual se puede aplicar
 un 
\begin_inset Quotes eld
\end_inset

experimento
\begin_inset Quotes erd
\end_inset

 con el objeto de responder preguntas sobre el sistema.
\end_layout

\begin_layout Standard
Esta definición implica que un modelo se puede utilizar para responder preguntas
 sobre un sistema sin tener que realizar experimentos sobre el sistema real.
 En su lugar se realizan algo así como 
\begin_inset Quotes eld
\end_inset

experimentos
\begin_inset Quotes erd
\end_inset

 simplificados sobre el modelo, el cual a su vez puede ser considerado como
 una sistema simplificado que refleja ciertas propiedades del sistema real.
\end_layout

\begin_layout Standard
Existen diferentes formas de representar un modelo:
\end_layout

\begin_layout Itemize
Modelo mental: una declaración como 
\begin_inset Quotes eld
\end_inset

esa persona es confiable
\begin_inset Quotes erd
\end_inset

 nos ayuda a responder preguntas acerca del comportamiento de esa persona
 en varias situaciones.
\end_layout

\begin_layout Itemize
Modelo verbal: este tipo de modelos se expresan en palabras.
 Por ejemplo, la oración 
\begin_inset Quotes eld
\end_inset

van a ocurrir más accidentes si se incrementa el límite de velocidad
\begin_inset Quotes erd
\end_inset

 es un ejemplo de un modelo verbal.
 Los sistemas expertos son una manera de formalizar estos modelos.
\end_layout

\begin_layout Itemize
Modelo físisco: esto es un objeto físico que imita ciertas propiedades del
 sistema real para ayudar a responder ciertas preguntas sobre dicho sistema.
 Por ejemplo, durante el diseño de artefactos como edificios, aviones, etc,
 es común construir un modelo físico pequeno con la misma forma y apariencia
 que el modelo real que se pretende estudiar.
\end_layout

\begin_layout Itemize
Modelo matemático: es una descripción de un sistema en donde las relaciones
 entre las variables del sistema se expresan en forma matemática.
 Las variables pueden ser cantidades medibles como tamaño, longitud, peso,
 temperatura, nivel de desempleo, flujo de información, etc.
 La mayoria de las leyes de físicas son modelos matemáticos en este sentido.
\end_layout

\begin_layout Standard
Este trabajo trata con modelos matemáticos representados de varias maneras,
 por ejemplo como ecuaciones, funciones, programas de computadora, etc.
 
\end_layout

\begin_layout Subsection
Simulación
\end_layout

\begin_layout Standard
En la sección anterior mencionamos la posibilidad de realizar 
\begin_inset Quotes eld
\end_inset

experimentos
\begin_inset Quotes erd
\end_inset

 sobre modelos en lugar de hacerlo sobre los sistemas reales correspondientes
 con los modelos.
 Este es uno de los usos principales de los modelos y se denota con el término
 simulación.
 Definimos una simulación de la siguiente manera:
\end_layout

\begin_layout Itemize
Una simulación es un experimento realizado sobre un modelo.
\end_layout

\begin_layout Standard
A continuación vamos a ver algunos ejemplos de simulaciones:
\end_layout

\begin_layout Itemize
La simulación de un proceso industrial como la producción de acero o papel
 para aprender sobre el comportamiento bajo diferentes condiciones de operación
 con el objetivo de mejorar el proceso.
\end_layout

\begin_layout Itemize
La simulación del comportamiento de un vehiculo, por ejemplo un auto o un
 avión, para que el conductor o piloto pueda disponer de un entrenamiento
 realistico.
\end_layout

\begin_layout Itemize
La simulación de un modelo simplificado de una red de computadoras para
 aprender como se comporta bajo diferentes cargas con el objetivo de mejorar
 la eficiencia.
\end_layout

\begin_layout Standard
¿Dada la utilidad de la simulación a la hora de estudiar el comportamiento
 de los sistemas, como hacemos para construir modelos de esos sistemas?
 Existen lenguajes de programación que facilitan la construcción de modelos
 de sistemas.
 Uno de esos lenguajes es Modelica.
 En la sección siguiente vamos a introducir este lenguaje de modelado el
 cual es parte fundamental del contexto de esta tesina.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Modelica"

\end_inset

Modelica
\end_layout

\begin_layout Standard
Modelica es un lenguaje orientado a objetos desarrollado para describir
 de manera sencilla modelos de sistemas dinámicos eventualmente muy complejos.
\end_layout

\begin_layout Standard
Además de las características básicas de todo lenguaje orientado a objetos,
 Modelica contiene herramientas específicas que permiten describir las relacione
s constitutivas de los distintos componentes de cada modelo y las relaciones
 estructurales que definen la interacción entre dichos componentes.
\end_layout

\begin_layout Standard
De esta manera, el lenguaje permite asociar cada componente de un sistema
 a una instancia de una clase de Modelica.
 Adicionalmente, los componentes típicos de los sistemas de distintos domínios
 de la física y de la técnica pueden agruparse en librerías de clases para
 ser reutilizados.
 De hecho, existe una librería estándar de clases de Modelica, que contiene
 los principales componentes básicos de sistemas eléctricos, mecánicos (traslaci
onales, rotacionales y multicuerpos), térmicos, state graphs, y diagramas
 de bloques.
 Otras librerías (disponibles en la web) contienen componentes de sistemas
 hidráulicos, bond graphs, redes de petri, etc.
\end_layout

\begin_layout Standard
Los modelos modelica son acausales.
 Esto significa que son modelos basados en ecuaciones más que en asignaciones.
 La principal ventaja de este tipo de modelado es que la dirección de la
 solución de las ecuaciones es adaptable al flujo de datos del contexto
 en el que se computa.
 El flujo de datos se define estableciendo que variables son necesarias
 como 
\shape italic
salidas
\shape default
, y cuales son 
\shape italic
entradas
\shape default
 externas al sistema simulado.
 La acausalidad de las clases de la biblioteca de Modelica las hacen más
 reutilizables que las clases que contienen asignaciones donde la causalidad
 entrada-salida es fija.
\end_layout

\begin_layout Section
Causalización
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Revisar este párrafo
\end_layout

\end_inset

 Como se menciono en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Modelica"

\end_inset

 los modelos modelica son acausales.
 Esta característica de los modelos que facilita su reutilización presenta
 un desafio para el compilador el cual debe producir como salida un modelo
 donde las ecuaciones se encuentren ordenadas de manera tal que puedan ser
 resueltas secuencialmente al momento de la simulación.
\end_layout

\begin_layout Standard
Para ordenar las ecuaciones se realiza un procesamiento del modelo denominado
 causalización.
 Esta etapa del proceso de compilación constituye el tema principal de esta
 tesina.
\end_layout

\begin_layout Standard
El proceso de causalización consiste en ordenar topologicamente un conjunto
 de ecuaciones acausales de acuerdo a las dependencias del flujo de datos
 entre ellas.
 El objetivo de este ordenamiento es que las ecuaciones puedan resolverse
 de manera secuencial uno después de la otra.
\end_layout

\begin_layout Standard
Para lograr la causalización de las ecuaciones de un modelo modelica se
 utiliza un algoritmo de teoria de grafos denominado Algoritmo de Tarjan.
 Dicho algoritmo permite encontrar los componentes fuertementes conexos
 de un grafo.
 Este algoritmo posee la propiedad de que ningún componente fuertemente
 conexo es identificado antes que sus sucesores.
 De esta manera el orden en que los componentes fuertemente conexos son
 encontrados representa un orden topológico reverso del grafo dirigido acíclico
 formado por los componentes fuertemente conexos.
 Esta propiedad del algoritmo de Tarjan es la lo hace apropiado para resolver
 el problema de causalización de ecuaciones.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

 mostramos como se aplica este algoritmo en el contexto de un compilador
 modelica.
\end_layout

\begin_layout Part
Preliminares
\end_layout

\begin_layout Chapter
Marco teórico
\end_layout

\begin_layout Section
Modelica
\end_layout

\begin_layout Standard
Modelica es un lenguaje de modelado que permite la especificación de modelos
 matemáticos de complejos sistemas naturales o artificiales con el propósito
 de posibilitar la simulación computarizada de sistemas dinámicos que evoluciona
n con el tiempo.
 Modelica es también un lenguaje de programación orientado a objetos y basado
 en ecuaciones, pensado para aplicaciones de mucha complejidad que requieren
 una alta eficiencia.
 Las cuatro características principales son:
\end_layout

\begin_layout Itemize
Modelica esta principalmente basado en ecuaciones en lugar de asignaciones.
 Esto permite un modelado acausal (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Modelado-Físico-Acausal"

\end_inset

) lo cual facilita la reutilización de las clases ya que las ecuaciones
 no especifican una dirección particular para el flujo de datos.
 De esta manera una clase modelica se puede adaptar a contextos con diferentes
 flujos de datos.
\end_layout

\begin_layout Itemize
Modelica permite describir y conectar componentes de modelos pertenecientes
 a diferentes dominios como electricidad, mecánica, termodinámica, hidráulica,
 biología y control.
\end_layout

\begin_layout Itemize
Modelica es un lenguaje orientado a objetos con un concepto general de clase
 que unifica las ideas de clases, tipos genéricos y subtipos en un solo
 lenguaje.
 Esto facilita la reutilización de componentes y la evolución de los modelos.
\end_layout

\begin_layout Standard
Estas son las propiedades que hacen a Modelica un lenguaje potente y fácil
 de utilizar, especialmente para modelado y simulación.
\end_layout

\begin_layout Subsection
Conceptos básicos
\end_layout

\begin_layout Standard
Un programa modelica se construye a partir de clases, también denominadas
 modelos.
 A partir de la definición de una clase es posible crear cualquier número
 de objetos que se conocen como instancias de esa clase.
\end_layout

\begin_layout Standard
Una clase modelica contiene elementos, los principales son declaraciones
 de variables y ecuaciones; las ecuaciones se agrupan en secciones.
 Las variables contienen datos pertenecientes a instancias de una clase.
 Las ecuaciones de una clase especifican el comportamiento de las instancias
 de dicha clase.
\end_layout

\begin_layout Standard
La tradición establece que el primer programa de ejemplo cualquiera sea
 el lenguaje de programación es un programa sencillo que simplemente imprime
 la cadena de caracteres 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

.
 Dado que modelica es un lenguaje basado en ecuaciones, imprimir una cadena
 de caracteres no tiene mucho sentido.
 En su lugar nuestro primer programa modelica resuelve una ecuación diferencial
 trivial.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dot{x}=-a\times x
\]

\end_inset


\end_layout

\begin_layout Standard
La variable 
\begin_inset Formula $x$
\end_inset

 en esta ecuación es una variable dinámica (en este ejemplo también es una
 variables de estado) cuyo valor puede variar con el transcurso del tiempo.
 La derivada del tiempo 
\begin_inset Formula $\dot{x}$
\end_inset

 es la derivada temporal de 
\begin_inset Formula $x$
\end_inset

, lo cual en modelica se representa como 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+der(x)+
\end_layout

\end_inset

.
 Dado que todos los programas en modelica, llamados modelos, consisten en
 declaraciones de clases nuestro programa HelloWorld se declara como una
 clase:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

class HelloWorld
\end_layout

\begin_layout Plain Layout

  Real x(start = 1);
\end_layout

\begin_layout Plain Layout

  parameter Real a = 1;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(x) = -a*xi
\end_layout

\begin_layout Plain Layout

end HelloWorld;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El programa contiene la declaración de una clase llamada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+HelloWorld+
\end_layout

\end_inset

 con dos variables y una sola ecuación.
 El primer atributo de la clase es la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

, la cual es inicializada al valor 1 en el momento en el que se inicia la
 simulación.
 Todas las variables en Modelica tienen un atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

 con un valor por defecto el cual usualmente es 0.
\end_layout

\begin_layout Standard
El segundo atributo es la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+a+
\end_layout

\end_inset

 la cual es una constante inicializada a 1 al momento de iniciarse la simulación.
 Las constantes de este tipo se declaran utilizando el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 para indicar que permancen constantes durante la simulación pero que es
 un parámetro del modelo que puede tomar un valor distinto para cada simulación,
 por ejemplo mediante algún comando del entorno de simulación.
\end_layout

\begin_layout Standard
Notar también que las variables poseen un tipo que las antecede cuando se
 declaran.
 En nuestro ejemplo ambas variables poseen el tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La única ecuación de nuestro ejemplo especifica que la derivada temporal
 de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

 es igual a la multiplicación de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+-a+
\end_layout

\end_inset

 por 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

.
 En Modelica el signo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+=+
\end_layout

\end_inset

 siempre significa igualdad, esto es, define una ecuación y no una asignación
 como en la mayoría de los lenguajes de programación.
 La derivada temporal de una variable se indica mediante la pseudo-función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+der()+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Nuestro segundo ejemplo es un poco más complicado.
 Es el modelo matemático de un sistema físico, un péndulo plano.
 Las 5 ecuaciones del modelo se ven a continuación.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Falta el diagrama.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
m\dot{v}_{y} & = & -\frac{x}{L}F\\
m\dot{v}_{y} & = & -\frac{y}{L}F-mg\\
\dot{x} & = & v_{x}\\
\dot{y} & = & v_{y}\\
x^{2}+y^{2} & = & L^{2}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Las ecuaciones son las ecuaciones de movimiento de Newton para la masa del
 péndulo bajo la influencia de la gravedad junto con una restricción geométrica,
 la 5ª ecuación, que especifica que la posición 
\begin_inset Formula $(x,y)$
\end_inset

 del péndulo debe encontrarse dentro de un circulo con radio 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Standard
Lo interesante de este modelo es que la 5ª ecuación es diferente al resto,
 es una ecuación algebraica la cual involucra solo operaciones algebraicas
 sobre las variables pero no derivadas.
 Las otras cuatro ecuaciones son ecuaciones diferenciales, como la ecuación
 del ejemplo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+HelloWorld+
\end_layout

\end_inset

.
 Los sistemas de ecuaciones que contienen tanto ecuaciones diferenciales
 como ecuaciones algebraicas se denominan sistemas de ecuaciones diferenciales
 algebraicas (o DAEs por sus siglas en ingles).
 Debajo se encuentra el modelo modelica del péndulo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Corregir.
 Ver el modelo original
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

class Pendulum "Planar Pendulum"
\end_layout

\begin_layout Plain Layout

  constant Real PI=3.141592653589793;
\end_layout

\begin_layout Plain Layout

  parameter Real m=l, g=9.81, L=O.S;
\end_layout

\begin_layout Plain Layout

  Real Fj output Real x(start=O.5) ,y(start=O);
\end_layout

\begin_layout Plain Layout

  output Real VX,VYi
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    m*der(vx)=-(x/L)*Fi
\end_layout

\begin_layout Plain Layout

    m*der(vy)=-(y/L)*F-m*gi
\end_layout

\begin_layout Plain Layout

    der(x)=vxi der(y)=VYi
\end_layout

\begin_layout Plain Layout

    x^2 + y^2 = L^2 ;
\end_layout

\begin_layout Plain Layout

end Pendulum;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último hacemos una observación importante en relación a los modelos
 Modelica.
\end_layout

\begin_layout Quotation
El número de variables debe ser igual al número de ecuaciones.
\end_layout

\begin_layout Standard
Esta regla es respetada por los dos modelos que vimos en esta sección y
 debe ser respetada por cualquier modelo para ser considerado resoluble.
 Por variables nos referimos a algo que pueda variar, no constantes ni parámetro
s.
\end_layout

\begin_layout Subsubsection
Variables
\end_layout

\begin_layout Standard
El modelo que vamos a ver a continuación muestra un modelo levemente más
 complicado.
 El cual describe un oscilador de Van der Pol.
 Notar que en este ejemplo la palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+model+
\end_layout

\end_inset

 se utiliza en lugar de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+class+
\end_layout

\end_inset

 casi con el mismo significado.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

model VanDerPol "Van der Pol oscillator model"
\end_layout

\begin_layout Plain Layout

  Real x(start = 1) "Descriptive string for x";
\end_layout

\begin_layout Plain Layout

  Real y(start = 1) "Descriptive string for y";
\end_layout

\begin_layout Plain Layout

  parameter Real lambda = 0.3;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(x) = Yi
\end_layout

\begin_layout Plain Layout

    der(y) = -x + lambda*(l - x*x)*y;
\end_layout

\begin_layout Plain Layout

end VanDerPol;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este ejemplo contiene la declaración de dos variables dinámicas (las cuales
 en este caso también son variables de estado) 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x+
\end_layout

\end_inset

 e 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+y+
\end_layout

\end_inset

, ambas de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 y con valor inicial 1 al comienzo de la simulación, lo cual normalmente
 es al momento 0.
\end_layout

\begin_layout Standard
La palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 especifica que la variable permanece constante durante la simulación, pero
 que su valor se puede inicializar antes de una ejecución o entre ejecuciones.
 Un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 es una variable constante que permite al usuario modificar de manera sencilla
 el comportamiento de un modelo, por ejemplo modificando el parámetro 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+lambda+
\end_layout

\end_inset

 el cual influencia considerablemente el comportamiento del oscilador de
 Van der Pol.
 Por el contrario, una constante Modelica declarada con el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+constant+
\end_layout

\end_inset

 nunca cambia y puede ser sustituida por su valor en los lugares donde ocurra.
\end_layout

\begin_layout Standard
Por último hay una sección para ecuaciones declarada con la palabra clave
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

, conteniendo dos ecuaciones mutuamente dependientes que definen la dinámica
 del modelo.
\end_layout

\begin_layout Standard
Los nombres de variables, funciones, clases, etc.
 se conocen como identificadores.
 Existen de dos tipos en modelica.
 El más común comienza con una letra seguido de letras o dígitos, por ejemplo
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+x1+
\end_layout

\end_inset

.
 El otro tipo de identificadores comienza con una comilla simple seguido
 por cualquier carácter y terminado también con una comilla simple, por
 ejemplo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+'2nd*3'+
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Arreglos
\end_layout

\begin_layout Standard
Un arreglo es una colección de variables todas del mismo tipo.
 Los elementos de un arreglo se acceden por medio de indices enteros cuyos
 valores van desde 1 hasta el tamaño de la respectiva dimensión.
 Una variable de tipo arreglo se puede declarar agregando dimensiones entre
 corchetes después del nombre de una clase, como en Java, o después del
 nombre de una variable, como en C.
 Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

  Real[3] positionvector = {1,2,3};
\end_layout

\begin_layout Plain Layout

  Real[3,3] identitymatrix = {{1,0,0}, {0,1,0}, {0,0,1}};
\end_layout

\begin_layout Plain Layout

  Real[3,3,3] arr3d;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esto declara un vector, una matriz de transformación y un arreglo de dimensión
 3.
\end_layout

\begin_layout Standard
Más detalles sobre arreglos en modelica se pueden encontrar en 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262"

\end_inset

.
\end_layout

\begin_layout Subsection
Modelado matemático orientado a objetos
\end_layout

\begin_layout Standard
Los lenguajes orientados a objetos tradicionales como Smalltalk, Java o
 C++, así como también los lenguajes procedurales como Fortran o C, soportan
 la programación sobre datos almacenados en memoria.
 Los datos almacenados en memoria corresponde a valores de variables y datos
 de objetos.
 El número de objetos usualmente cambia de manera dinámica.
 El enfoque de orientación a objetos de Smalltalk enfatiza el envío de mensajes
 entre objetos.
\end_layout

\begin_layout Standard
El enfoque de Modelica del concepto de orientación a objetos es diferente
 ya que Modelica enfatiza el modelado matemático estructurado.
 La orientación a objetos es vista como una forma de estructuración para
 poder manejar la complejidad de las descripciones de grandes sistemas.
 Un Modelo modelica es principalmente una descripción matemática declarativa.
 Las propiedades de los sistemas dinámicos se expresan de manera declarativa
 mediante ecuaciones.
 
\end_layout

\begin_layout Standard
El enfoque declarativo de Modelica sobre la orientación a objetos se puede
 resumir en estos puntos:
\end_layout

\begin_layout Itemize
La orientación a objetos es utilizada como un concepto de estructuración,
 enfatizando la estructura declarativa y la reutilización de los modelos
 matemáticos.
 Las tres maneras de estructurar son jerarquías, conexiones entre componentes
 y herencia.
\end_layout

\begin_layout Itemize
Las propiedades de los modelos dinámicos se expresan de manera declarativa
 utilizando ecuaciones.
\end_layout

\begin_layout Itemize
Un objeto es una colección de variables de instancia y ecuaciones que comparten
 un conjunto de datos.
\end_layout

\begin_layout Standard
No obstante
\end_layout

\begin_layout Itemize
La orientación a objetos en el modelado matemático no es considerado como
 un intercambio de mensajes entre objetos.
\end_layout

\begin_layout Standard
La forma declarativa y orientada a objetos de describir sistemas y su comportami
ento que ofrece Modelica es de un nivel más alto de abstracción del que
 poseen los lenguajes orientados a objetos tradicionales ya que ciertos
 detalles de implementación se omiten.
 Por ejemplo, no es necesario escribir código para transportar datos de
 un objeto a otro mediante asignaciones.
 Ese código lo genera automáticamente el compilador de Modelica a partir
 de las ecuaciones dadas.
\end_layout

\begin_layout Standard
De la misma manera que ocurre en los lenguajes orientados a objetos ordinarios
 las clases son plantillas para la creación de objetos.
 Tanto variables como ecuaciones pueden ser heredadas entre clases.
 También las definiciones de funciones pueden ser heredadas.
 No obstante, la especificación de comportamiento de realiza principalmente
 mediante ecuaciones en lugar de métodos.
 También el lenguaje permite escribir código en forma de algoritmos incluyendo
 funciones pero esto es una excepción más que una regla.
\end_layout

\begin_layout Standard
Dado que este trabajo se centra en la etapa de causalización y que en ese
 momento del proceso de compilación el modelo ya se encuentra aplanado,
 es decir solo se compone de variables de tipos básicos y ecuaciones, no
 ahondaremos más en las particularidades del sistema de clases de modelica.
 El lector interesado puede consultar en 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
\end_layout

\begin_layout Subsection
Ecuaciones
\end_layout

\begin_layout Standard
Como ya hemos mencionado, modelica es principalmente un lenguaje basando
 en ecuaciones a diferencia de los lenguajes de programación ordinarios
 donde proliferan las asignaciones.
 Las ecuaciones son más flexibles que las asignaciones dado que no determinan
 un flujo de datos u orden de ejecución particular.
 Esta es la clave de las capacidades de modelado de sistemas físicos y del
 potencial de reutilización de las clases modelica.
\end_layout

\begin_layout Standard
Pensar en términos de ecuaciones es poco usual para la mayoría de los programado
res.
 En modelica tienen lugar las siguientes afirmaciones:
\end_layout

\begin_layout Itemize
Lo que en lenguajes convencionales se define con asignaciones en general
 en modelica se define con ecuaciones.
\end_layout

\begin_layout Itemize
La asignación de valores a atributos se representa como ecuaciones.
\end_layout

\begin_layout Itemize
Las conexiones entre objetos generan ecuaciones.
\end_layout

\begin_layout Standard
Las ecuaciones son más poderosas que las asignaciones.
 Por ejemplo, consideremos la ecuación de una resistencia R que multiplicada
 por la corriente i es igual a el voltaje v.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R\times i & =v
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Esta ecuación puede ser utilizada de tres maneras correspondientes a tres
 asignaciones posibles: calcular la corriente a partir del voltaje y de
 la resistencia, calcular el voltaje a partir de la resistencia y de la
 corriente o calcular la resistencia a partir del voltaje y de la corriente.
 A continuación vemos las tres posibles asignaciones:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
i & :=\frac{v}{R}\\
v & :=R\times i\\
R & :=\frac{v}{i}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Las ecuaciones en modelica se pueden clasificar de forma informal en cuatro
 grupos dependiendo en el contexto sintáctico en el que aparezcan:
\end_layout

\begin_layout Itemize
Ecuaciones normales, las cuales aparecen en la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Ecuaciones que aparecen en la sección de declaraciones y forman parte de
 la declaración de una variable o constante.
\end_layout

\begin_layout Itemize
Ecuaciones como modificadores las cuales se utilizan para modificar atributos.
\end_layout

\begin_layout Itemize
Ecuación de inicialización las cuales se especifican en la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+initial equation+
\end_layout

\end_inset

 o como para indicar el valor del atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

.
 Estas ecuaciones se utilizan para resolver el problema de inicialización
 al momento de inicio de la ejecución.
\end_layout

\begin_layout Standard
Como ya hemos visto en los ejemplos anteriores las ecuaciones normales aparecen
 en las secciones delimitadas por la palabra clave 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

 y por alguna otra palabra clave permitida:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

	equation
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		<equations>
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	<some other allowed keyword> 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La ecuación de la resistencia que mostramos más arriba es un ejemplo de
 una ecuación que puede ser ubicada en una sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
 Las ecuaciones que aparecen en la sección de declaraciones generalmente
 se utilizan como parte de la declaración de constantes paramétricas o fijas,
 por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

	constant Integer one = 1;
\end_layout

\begin_layout Plain Layout

	parameter Real mass = 22.5; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La veracidad de una ecuación se mantiene siempre, lo que significa que la
 masa en el ejemplo anterior nunca varia durante la simulación.
 También es posible especificar una ecuación en la declaración de una variable
 común, por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

	Real speed = 72.4; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sin embargo esto no tiene mucho sentido ya que va a restringir la variable
 a que tenga el mismo valor durante toda la ejecución haciendo que se comporte
 como una constante.
 De esta manera se puede notar que la utilización de una ecuación en la
 declaración de una variable es bastante diferente de la inicialización
 de una variable en otros lenguajes.
\end_layout

\begin_layout Standard
Las asignaciones de valores a atributos se realizan utilizando ecuaciones
 como modificadores.
 Por ejemplo, si necesitamos especificar un valor inicial para una variable
 lo que hacemos es definir una ecuación para el atributo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+start+
\end_layout

\end_inset

 de la variable:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

	Real speed(start=72.4); 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que la causalización se aplica sobre las ecuaciones normales,
 es decir las declaradas en las secciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Ecuaciones con Estructuras Repetitivas
\end_layout

\begin_layout Standard
A veces surge la necesidad de expresar convenientemente conjuntos de ecuaciones
 con estructuras que se repiten.
 Para estos casos modelica ofrece un tipo particular de ecuación denonimado
 loop equation.
 Notar que esto no es un bucle en el sentido algoritmico de la palabra sino
 que es una forma abreviada de expresar un conjunto de ecuaciones.
\end_layout

\begin_layout Standard
Por ejemplo, consideremos una ecuación para una expresión polinomial:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{aligned}y & = & a[1]+a[2]\times x+a[3]\times x^{2}+\ldots+a[n+1]\times x^{n}\end{aligned}
$
\end_inset


\end_layout

\begin_layout Standard
La ecuación polinomial se puede expresar como un conjunto de ecuaciones
 con la misma estrucutra más una ecuación adicional donde 
\begin_inset ERT
status open

\begin_layout Plain Layout

$y$
\end_layout

\end_inset

 es igual al producto escalar de los vectores a y xpowers, ambos de logitud
 n+1:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

  xpowers[1] = 1;
\end_layout

\begin_layout Plain Layout

  xpowers[2] = xpowers[1]*x;
\end_layout

\begin_layout Plain Layout

  xpowers[3] = xpowers[2]*x;
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  xpowers[n+1] = xpowers[n]*x;
\end_layout

\begin_layout Plain Layout

  y = a * xpowers;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El conjunto de ecuaciones sobre las variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+xpowers+
\end_layout

\end_inset

 se pueden expresar de manera más conveniente utilizando la notación 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

  for i in 1:n loop
\end_layout

\begin_layout Plain Layout

    xpowers[i+1] = xpowers[i]*x;
\end_layout

\begin_layout Plain Layout

  end for;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Modelado-Físico-Acausal"

\end_inset

Modelado Físico Acausal
\end_layout

\begin_layout Standard
El modelado acausal es un estilo declarativo de modelado, que significa
 modelado basado en ecuaciones más que en asignaciones.
 Las ecuaciones no especifican que variables son de entrada y cuales son
 de salida, mientras que en las asignaciones las variables del lado izquierda
 siempre son de salida y las variables del lado derecho siempre son entradas.
 Por la tanto la causalidad de los modelos basados en ecuaciones es indeterminda
 y solo se determina cuando los correspondientes sistemas de ecuaciones
 se resuelven.
 A esto es a lo que se denomina modelado acausal.
 El termino modelado físico refleja el hecho de que el modelado acausal
 es muy apropiado para representar la estructura física de los sistemas
 modelados.
\end_layout

\begin_layout Standard
La principal ventaja del modelado acausal es que la dirección de la solución
 de las ecuaciones es adaptable al flujo de datos del contexto en el que
 se computa la solución.
 El flujo de datos se define estableciendo que variables son necesarias
 como 
\shape italic
salidas
\shape default
, y cuales son 
\shape italic
entradas
\shape default
 externas al sistema simulado.
 
\end_layout

\begin_layout Standard
La acausalidad de las clases de la biblioteca de Modelica las hacen más
 reutilizables que las clases que contienen asignaciones donde la causalidad
 entrada-salida es fija.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Implementación-y-ejecución"

\end_inset

Implementación y ejecución de Modelica
\end_layout

\begin_layout Standard
En esta sección vamos a detallar brevemente los pasos necesarios para traducir
 código Modelica en código ejecutable.
\end_layout

\begin_layout Standard
En primer lugar se realiza un análisis sintáctico del código fuente Modelica
 del cual se obtiene un árbol sintáctico abstracto.
 Luego esta representación se analiza gramaticalmente, se realiza la verificació
n de tipos, las clases se heredan y expanden, se realizan las modificaciones
 e instanciaciones correspondientes, las ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 se convierten en ecuaciones comunes, etc.
 El resultado de este proceso de análisis y traducción es un conjunto plano
 de ecuaciones, constantes, variables y funciones.
 No queda ningún rastro de la estructura de objetos.
\end_layout

\begin_layout Standard
Después del proceso de aplanado todas las ecuaciones se ordenan topológicamente
 de acuerdo a las dependencias del flujo de datos entre ellas.
 En el caso de ecuaciones diferenciales algebraicas, no solo se realiza
 un ordenamiento, sino que también es necesario manipular las ecuaciones
 para convertir la matriz de coeficientes a forma triangular inferior de
 a bloques, lo que usualmente se denomina transformación BLT por sus siglas
 en ingles 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
 Luego un módulo de optimización compuesto por algoritmos de simplificación
 algebraica, métodos de reducción de índices, etc., elimina la mayoría de
 las ecuaciones dejando solo un conjunto mínimo que eventualmente va a ser
 resuelto numéricamente.
 Por ejemplo, si dos ecuaciones sintácticamente equivalentes aparecen solo
 se conserva una.
\end_layout

\begin_layout Standard
La etapa siguiente consiste en convertir las ecuaciones independientes resultant
es en asignaciones.
 Esto es posible dado que las ecuaciones fueron ordenadas y se determino
 una secuencia de ejecución para la evaluación de las ecuaciones.
 Si aparece un conjunto de ecuaciones fuertemente conectadas (un bucle algebraic
o) se aplica un resolvedor simbólico el cual ejecuta una serie de transformacion
es algebraicas para simplificar las dependencias entre las variables.
 En ciertos casos el resolvedor puede resolver el sistema de ecuaciones
 diferenciales si este posee solución simbólica.
\end_layout

\begin_layout Standard
Finalmente se genera código en algún lenguaje de programación convencional,
 usualmente C, y se lo enlaza con algún resolvedor numérico de ecuaciones
 el cual es el encargado de resolver el sistema de ecuaciones resultante
 el cual ya a sido drásticamente reducido.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:compilacion_modelica}
\end_layout

\end_inset

 se pueden ver las distintas etapas del proceso de traducción y ejecución.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.3
\backslash
textwidth]{graphics/EtapasCompilacion.jpg}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Etapas del proceso de compilación y ejecución de modelica.}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:compilacion_modelica}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Tipos de ecuaciones presente en modelos matemáticos
\end_layout

\begin_layout Standard
En esta sección vamos a ver un repaso de diferentes tipos de ecuaciones
 y variables, y como se relacionan con el lenguaje Modelica.
\end_layout

\begin_layout Subsection
Categorías de variables y constantes
\end_layout

\begin_layout Standard
Antes de comenzar a describir los distintos tipos de ecuaciones resulta
 conveniente definir los distintos tipos de variables y constantes que se
 pueden encontrar en las ecuaciones.
\end_layout

\begin_layout Standard
A continuación vamos a ver una lista de definiciones de variables y constantes
 asumiendo diferentes roles en los modelos matemáticos.
 Estos roles usualmente no son una propiedad del modelo o del sistema modelado
 sino una consecuencia de la combinación del modelo, algunos experimentos
 o simulación y condiciones dadas a partir de lo que queremos estudiar.
 Sin embargo, hay que tener en cuenta que los modelos pueden ser formulados
 de manera más o menos genérica o reutilizable.
 Un modelo acausal basado en ecuaciones se ajusta a varios contextos de
 flujo de datos diferentes donde las variables asumen diferentes roles,
 p.
 ej.
 como entrada o salida, mientras que un modelo en donde las variables han
 sido fijadas como entradas o salidas solo se ajusta a algunas pocas configuraci
ones de experimentación.
\end_layout

\begin_layout Itemize

\series bold
Constante:
\series default
 una cantidad en el modelo que no varia con el tiempo.
 Este tipo de cantidades se declaran con el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+constant+
\end_layout

\end_inset

 en Modelica.
\end_layout

\begin_layout Itemize

\series bold
Parámetro de modelo:
\series default
 una constante en el modelo que es determinada por el sistema, o una constante
 que puede ser modificada con el fin de darle diferentes propiedades al
 sistema.
 Se declara con el prefijo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+parameter+
\end_layout

\end_inset

 y permance constante durante la simulación pero puede ser modificado entre
 ejecuciones.
\end_layout

\begin_layout Itemize

\series bold
Variable:
\series default
 una cantidad en el modelo que varia respecto del tiempo.
\end_layout

\begin_layout Itemize

\series bold
Variable de salida:
\series default
 una variable cuyo comportamiento queremos observar.
 Usualmente denotada como 
\begin_inset Formula $y(t)$
\end_inset

.
 El rol de variable de salida no esta establecido por el sistema que se
 modela sino que es determinado por lo que el modelador quiere estudiar.
 No obstante es frecuente que también queramos observar algunas variables
 de estado (ver debajo).
\end_layout

\begin_layout Itemize

\series bold
Variable de entrada:
\series default
 una variable que afecta el comportamiento del modelo sin ser afectada por
 otras variables del modelo y cuyas variaciones respecto del tiempo pueden
 ser controladas.
 Usualmente se las denota 
\begin_inset Formula $u(t)$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Variable de estado.
\end_layout

\begin_deeper
\begin_layout Itemize
Para modelos ODE: una variable que no es ni de entrada ni de salida y que
 aparece su derivada respecto del tiempo, usualmente denotada por 
\begin_inset Formula $x(t)$
\end_inset

, y su derivada temporal 
\begin_inset Formula $\dot{x(t)}$
\end_inset

.
 En Modelica una variable de estado debe ser de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 o algún subtipo de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

.
 Si queremos estudiar alguna variable de estado 
\begin_inset Formula $x_{i}(t)$
\end_inset

siempre podemos agregar una variable de salida asociada 
\begin_inset Formula $y_{j}(t)$
\end_inset

 junto con la ecuación 
\begin_inset Formula $y_{j}(t)=x_{i}(t)$
\end_inset

, o directamente observar la variable de estado.
\end_layout

\begin_layout Itemize
Para modelos DAE: el conjunto de variables de estado es una selección de
 algunas variables dinámicas 
\begin_inset Formula $x(t)$
\end_inset

 junto con algunas variables algebraicas 
\begin_inset Formula $y(t)$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Porque nosotros elegimos las variables de estado como si el modelo siempre
 fuese ODE ?
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Variables algebraicas:
\series default
 una variable que aparece en la ecuaciones algebraicas pero que su derivada
 no aparece en el modelo.
 Usualmente se las incluye en el conjunto de variables denotadas por 
\begin_inset Formula $y(t)$
\end_inset

 aunque se este interesado en observar la variable.
\end_layout

\begin_layout Subsection
Ecuaciones diferenciales ordinarias
\end_layout

\begin_layout Standard
Las ecuaciones diferenciales ordinarias (o ODEs por sus siglas en ingles)
 aparecen en la mayoria de los modelos matemáticos de sistemas continuos
 dado que la dependencia respecto del tiempo en esos modelos generalmente
 se refleja por medio de derivadas respecto del tiempo de variables de estado
 correspondientes a dichos modelos.
 La ley de fuerza de Newton, la cual establece que la fuerza 
\begin_inset Formula $F$
\end_inset

 es igual a la masa 
\begin_inset Formula $m$
\end_inset

 por la segunda derivada 
\begin_inset Formula $\ddot{s}$
\end_inset

 de la posición 
\begin_inset Formula $s$
\end_inset

 con respecto al tiempo, es un ejemplo de ODE de segundo orden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\begin{aligned}m\ddot{s}(t)\end{aligned}
 & = & F(t)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Introduciendo una variable 
\begin_inset Formula $v(t)$
\end_inset

 nos podemos deshacer de la segunda derivada.
 Después de reacomodar la primer ecuación tenemos a todas las derivadas
 del lado izquierdo y todas son derivadas de primer orden.
 Esto significa que hemos transformado el sistema en uno ODE explícito de
 primer orden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\dot{x}(t) & = & \frac{F(t)}{m}\\
\dot{s}(t) & = & v(t)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Un sistema ODE de esta forma es especialmente eficiente para resolver númericame
nte.
 La estructura general de un sistema ODE en forma espacio temporal explícita
 es la siguiente, con variables de entrada 
\begin_inset Formula $u(t)$
\end_inset

, salidas 
\begin_inset Formula $y(t)$
\end_inset

, y variables de estado 
\begin_inset Formula $x(t)$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\dot{x}(t) & = & f(x(t),u(t))\\
y(y) & = & g(x(t),u(t))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Aqui también introdujimos variables de salida 
\begin_inset Formula $y(t)$
\end_inset

 que son directamente computables a partir de las variables de estado y
 las variables de entrada pero que no influencian la solución para las variables
 de estado 
\begin_inset Formula $x(t)$
\end_inset

.
\end_layout

\begin_layout Subsection
Ecuaciones algebraicas
\end_layout

\begin_layout Standard
Las ecuaciones algebraicas son relaciones entre variables que no involucran
 derivadas de ninguna variable.
 Estas ecuaciones aparecen naturalmente en modelos de sistemas naturales
 o artificiales, especialmente cuando hay involucrada alguna restricción.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Incluir diagrama del péndulo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por ejemplo, las coordenadas cartesianas 
\begin_inset Formula $\{x_{1},x_{2}\}$
\end_inset

 de la masa en el péndulo de la figura 
\begin_inset Note Note
status open

\begin_layout Plain Layout
incluir ref
\end_layout

\end_inset

 satisfacen la siguiente ecuación algebraica donde se establece que la longitud
 del pendulo es 
\begin_inset Formula $L$
\end_inset

 según la ley de Pitagoras:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
x_{1}^{2}+x_{2}^{2} & = & L^{2}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Las variables definidas por ecuaciones algebraicas y cuyas derivadas no
 aparecen en el modelo se denominan variables algebraicas.
 Alguna de estas variables también pueden ser variables de salida.
\end_layout

\begin_layout Standard
La forma general de un sistema de ecuaciones algebraicas (sin incluir ecuaciones
 diferenciales) es se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
g(x(t),u(t),y(t)) & = & 0
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Ecuaciones diferenciales algebraicas
\end_layout

\begin_layout Standard
Un sistema de ecuaciones algebraico (DAE, por sus siglas en ingles) incluye
 tanto ecuaciones difrenciales como ecuaciones algebraicas.
 Por ejemplo, el modelo que vemos a continuación, el cual corresponde a
 un péndulo, esta compuesto por ecuaciones diferenciales algebraicas, cinco
 de las ecuaciones del modelo son diferenciales y dos son algebraicas.
 Las variables del modelo son 
\begin_inset Formula $x_{1}$
\end_inset

, 
\begin_inset Formula $x_{2}$
\end_inset

, 
\begin_inset Formula $v_{1}$
\end_inset

, 
\begin_inset Formula $v_{2}$
\end_inset

, 
\begin_inset Formula $\varphi$
\end_inset

, 
\begin_inset Formula $\omega$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

 y las constantes 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $m$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

.
 Hemos reemplazado la ecuación correspondiente a la ley de Pitagóras por
 dos ecuaciones algebraicas sobre las variables 
\begin_inset Formula $x_{1}$
\end_inset

 y 
\begin_inset Formula $x_{2}$
\end_inset

 respectivamente, las cuales aún preservan la restricción sobre la longitud
 del péndulo.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
m\dot{v} & = & -F\sin(\varphi)\\
m\dot{v} & = & -F\cos(\varphi)-mg\\
\dot{x_{1}} & = & v_{1}\\
\dot{x}_{2} & = & v_{2}\\
\dot{\varphi} & = & \omega\\
x_{1} & = & L\sin(\varphi)\\
x_{2} & = & -L\cos\left(\varphi\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
La forma general de un sistema DAE, de la cual el ejemplo anterior es un
 caso particular donde 
\begin_inset Formula $x=\{x_{1},x_{2},v_{1},v_{2},\varphi\}$
\end_inset

, 
\begin_inset Formula $u=\{\}$
\end_inset

, 
\begin_inset Formula $y=\{$
\end_inset


\begin_inset Formula $\omega,F\}$
\end_inset

, se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f(x(t),\dot{x}(t),u(t),y(t) & = & 0\\
g(x(t),u(t),y(t) & = & 0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Que pasa con las ecuaciones en diferencia, ecuaciones condicionales y DAEs
 híbridas? Las tendria que incluir en el marco teórico.
 Como se manejan en el compilador.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ecuaciones de Espacio de estados para Sistemas Continuos
\end_layout

\begin_layout Standard
Previamente hemos definido una variable de estado como una variable que
 debe ser almacenada y actualizada durante la simulación para poder calcular
 las salidas del modelo.
 Para los sistemas de tiempo continuo estas variables son aquellas para
 las cuales sus derivadas respecto del tiempo aparecen en el modelo.
 Existe una formulación estandar de las ecuaciones de ciertos modelos matemático
s de sistemas dinámicos denominada modelos de espacio de estados explicitos,
 en donde las derivadas de las variables de estado aparecen explícitamente
 del lado izquierdo de las ecuaciones.
\end_layout

\begin_layout Standard
Estos modelos son atractivos como una representación matemática básica dado
 que usualmente resultan más eficientes de resolver y analizar que otros
 modelos más complicados, sirviendo a la vez para representar un espectro
 amplio de aplicaciones.
 Sin embargo hay que tener en cuenta que muchos modelos no pueden ser transforma
dos a la forma de espacio de estados explicito.
\end_layout

\begin_layout Subsection
Forma Explícita de Espacio de Estados
\end_layout

\begin_layout Standard
La forma básica de ecuaciones continuas ODE en forma de espacio de estados
 explícita se presenta debajo, donde 
\begin_inset Formula $x($
\end_inset

t) es el conjunto de variables de estados, 
\begin_inset Formula $u(t)$
\end_inset

representa las variables de entrada, y 
\begin_inset Formula $y(t)$
\end_inset

representa las variables de salida y/o las algebraicas.
 Se dice que el modelo se encuentra en forma de espacio de estados explícita
 si y solo si las derivadas se encuentran del lado izquierdo de la primer
 ecuación.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\dot{x}(t) & = & f(x(t),u(t))\\
y(t) & = & g(x(t),u(t))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Aqui 
\begin_inset Formula $\dot{x}(t)$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $u(t)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang spanish
 y 
\begin_inset Formula $y(t)$
\end_inset

 son vectores y 
\begin_inset Formula $f(t)$
\end_inset

 y 
\begin_inset Formula $g(t)$
\end_inset

 son funciones vectoriales.
 Los modelos de espacio de estados que no han sido manipulados y llevados
 a esta forma se encuentra en una forma implícita.
 La forma semi-explícita de una DAE es de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\dot{x}(t) & = & f(x(t),y(t),u(t))\\
y(t) & = & g(x(t),u(t))
\end{align*}

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Técnicas-númericas-y"

\end_inset

Técnicas númericas y simbólicas para simular modelos Modelica
\end_layout

\begin_layout Subsection
Simplificación Simbólica de Modelos Modelica
\end_layout

\begin_layout Standard
Como ya hemos mencionado en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementación-y-ejecución"

\end_inset

 luego del proceso de aplanado de la estructura de objetos lo que se obtiene
 es un sistema de ecuaciones diferenciales algebraicas.
 Simular un modelo Modelica en general consiste en resolver sistemas de
 ese tipo.
 Esta tarea no es trivial por varias razones:
\end_layout

\begin_layout Itemize
Las ecuaciones no solo poseen incógnitas de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 sino también 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Boolean+
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Integer+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+enumeration+
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
La naturaleza orientada a objetos de los modelos Modelica, los cuales usualmente
 consisten de muchos componentes conectados, resulta después del aplanado
 en sistemas DAE bastante dispersos (una matriz asociada con muchos ceros)
 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

.
\end_layout

\begin_layout Itemize
Las orientación a objetos da lugar a que los usuarios escriban modelos muy
 grandes, incluso modelos con varias cientos de miles de ecuaciones y variables.
 Modelos tan grandes plantean demandas especiales sobre las técnicas de
 solución.
\end_layout

\begin_layout Standard
Muchas de estas dificultades pueden ser resueltas manipulando simbólicamente
 el sistema de ecuaciones antes de aplicar un resolvedor numérico.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementación-y-ejecución"

\end_inset

 mencionamos el método de realizar una partición BLT, o ordenamiento topológico,
 del sistema de ecuaciones utilizando el algoritmo de Tarjan 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
 Este algoritmo encuentra los componentes fuertemente conexos conteniendo
 ecuaciones mutuamente dependientes, i.e bucles algebraicos.
 El particionado del sistema de ecuaciones posibilita una solución más eficiente
 reduciendo la cantidad de variables que tienen que ser manejadas por el
 resolvedor numérico en cada subsistema de ecuaciones.
 
\end_layout

\begin_layout Standard
Algunos de los subsitemas de ecuaciones simultaneas encontrados por el particion
ado BLT son lineales y pueden ser resueltos por resolvedores estandar de
 ecuaciones lineales.
 Otros sistemas resultan ser no lineales.
 Una técnica denominada 
\shape italic
tearing
\shape default
 puede reducir aún más el tamaño y contribuir a mejorar la eficiencia cuando
 se resuelven este tipo de sistemas de ecuaciones no lineales.
 La técnica de tearing permite resolver de manera secuencial pero iterativamente
 las ecuaciones de un subsistema eligiendo en cada iteración la 
\begin_inset Quotes eld
\end_inset

tearing variable
\begin_inset Quotes erd
\end_inset

 y comenzando con un primera aproximación del valor de la variable.
 La convergencia de este proceso no esta garantiza, sin embargo en la mayoria
 de los casos ocurre.
\end_layout

\begin_layout Standard
La necesidad de diferenciar numéricamente utilizando resolvedores númericos
 de DAEs puede ser reducida o eliminada empleando el algoritmo de Pantelides
 para la 
\shape italic
reducción de indice 
\shape default
el cual transforma simbólicamente el sistema de ecuaciones a una forma de
 menor índice.
 El sistema de ecuaciones resultantes con índice no mayor a 1 puede ser
 resuelto por resolvedores numericos de DAE como el DASSL 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

 y incluso en algunos casos utilizando simples métodos de resolución de
 ODEs.
\end_layout

\begin_layout Standard
Descripciones de la técnica de tearing y del algoritmo de Pantelides se
 pueden encontrar en los siguientes libros 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262,CK06"

\end_inset

.
 En la sección siguiente vamos a explicar en que consiste la transformación
 o particionado BLT del sistema de ecuaciones también denominado proceso
 de causalización de ecuaciones.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Transformación-BLT--"

\end_inset

Transformación BLT - Causalización
\end_layout

\begin_layout Standard
Los sistemas de ecuaciones diferenciales algebraicas resultantes de aplanar
 la estructura de objetos de un modelo modelica por lo general son grandes,
 dispersos (una matriz asociada con muchos ceros) y no lineales 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

.
\end_layout

\begin_layout Standard
Permutando las ecuaciones y las variables es posible transformar el sistema
 de ecuaciones, o mejor dicho la matriz asociada, a una forma triangular
 inferior de a bloques (o BLT por sus siglas en ingles).
 Una vez llevado a esta forma BLT el sistema puede ser resuelto casi secuencialm
ente.
 Vamos a explicar la idea utilizando un ejemplo simple el cual consiste
 de 3 ecuaciones no lineales
\begin_inset Formula 
\begin{align*}
h_{1}(z_{1},z_{3}) & = & 0\\
h_{2}(z_{2}) & = & 0\\
h_{3}(z_{1},z_{2}) & = & 0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{1} & = & \begin{array}{c}
\begin{array}{ccc}
z_{1} & z_{2} & z_{3}\end{array}\\
\left[\begin{array}{ccc}
1 & 0 & 1\\
0 & 1 & 0\\
1 & 1 & 0
\end{array}\right]
\end{array}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
La matriz 
\begin_inset Formula $S_{1}$
\end_inset

describe la estructura del sistema de ecuaciones.
 La entrada S
\begin_inset Formula $_{ij}$
\end_inset

 es 1 si la variable i aparece en la ecuacion j y 0 en caso contrario.
 Permutando las ecuaciones y las variables este conjunto de ecuaciones puede
 ser llevado a la forma BLT:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
h_{2}(z_{2}) & = & 0\\
h_{3}(z_{1},z_{2}) & = & 0\\
h_{1}(z_{1},z_{3}) & = & 0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{2} & = & \begin{array}{c}
\begin{array}{ccc}
z_{1} & z_{2} & z_{3}\end{array}\\
\left[\begin{array}{ccc}
1 & 0 & 0\\
1 & 1 & 0\\
0 & 1 & 1
\end{array}\right]
\end{array}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Este proceso se denomina particionado del conjunto de ecuaciones.
 La forma triangular inferior estricta de la matriz asociada al sistema
 permite ver el hecho de que las ecuaciones no lineales pueden ser resueltas
 una por vez de manera secuencial.
 Comenzamos resolviendo 
\begin_inset Formula $h_{2}$
\end_inset

 para la variable 
\begin_inset Formula $z_{2}$
\end_inset

, luego podemos resolver 
\begin_inset Formula $h3$
\end_inset

 para 
\begin_inset Formula $z_{1}$
\end_inset

 y finalmente podemos determinar 
\begin_inset Formula $z_{3}$
\end_inset

a partir de 
\begin_inset Formula $h_{1}$
\end_inset

.
 Si la variable a resolver aparece linealmente en una ecuación, la variable
 puede ser despejada mediante manipulación simbólica.
 En caso contrario se require una iteración local de Newton.
\end_layout

\begin_layout Standard
En general no es posible transformar la matriz asociada a la forma triangular
 inferior estricta.
 Sin embargo existen algoritmos eficientes para convertir la matriz a una
 forma triangular inferior de a bloques, esto es una forma cuasi-triangular
 inferior en donde a lo largo de la diagonal aparecen bloques de dimensión
 
\begin_inset Formula $\geqq1$
\end_inset

.
 Estos algoritmos garantizan que las dimensiones de los bloques que aparecen
 en la diagonal de la matriz son del menor tamaño posible.
 Es decir no se pueden obtener bloques más pequeños mediante la permutación
 de variables y ecuaciones.
 Los bloques de tamaño 
\begin_inset Formula $>1$
\end_inset

 corresponden a sistemas de ecuaciones que tienen que ser resueltos simultáneame
nte.
 En otras palabras los algoritmos de particionado encuentra bucles algebraicos
 de dimensiones mínimas.
\end_layout

\begin_layout Subsubsection
Algoritmos de grafos para obtener la transformación BLT
\end_layout

\begin_layout Standard
Duff 
\begin_inset CommandInset citation
LatexCommand citep
key "Duff:1978:ITA:355780.355785"

\end_inset

 prueba que la forma más eficiente de calcular la transformación BLT de
 una matriz es aplicando el algoritmo de Tarjan 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

 para grafos dirigidos.
\end_layout

\begin_layout Standard
Para poder describir el algoritmo de Tarjan resulta muy util asociar a la
 matriz un grafo dirigido compuesto por un conjunto de n nodos, etiquetados
 
\begin_inset Formula $1,2,3,\ldots,n$
\end_inset

 y un conjunto de aristas 
\begin_inset Formula $(i,j)$
\end_inset

 cada una de las cuales es un par ordenado de nodos correspondiente a una
 entrada 
\begin_inset Formula $S_{ij}$
\end_inset

 distinta de cero y ubicada fuera de la diagonal.
 Realizar una permutación de la matriz 
\begin_inset Formula $S$
\end_inset

 se corresponde con re-etiquetar los nodos del grafo.
\end_layout

\begin_layout Standard
Se dice que un subgrafo es fuertemente conexo si existe un camino desde
 cualquiera de sus nodos hacia cualquier otro nodo y que es un componente
 fuertemente conexo si no puede ser agrandado a otro subgrafo fuertemente
 conexo agregando nodos y las aristas asociadas.
 Claramente, cada nodo puede pertenecer solo a un componente fuertemente
 conexo (que puede componerse de un solo nodo) por lo tanto los componentes
 fuertemente conexos determinan una partición del grafo.
 Deber haber al menos un componente fuertemente conexo tal que no exista
 camino de ninguno de sus nodos hacia algún nodo de otro componente.
 Denominemos 
\begin_inset Formula $C_{1}$
\end_inset

a este componente.
 Los otros componentes fuertemente conexos 
\begin_inset Formula $C_{2},C_{3},\ldots,C_{k}$
\end_inset

 pueden ser elegidos aplicando el mismo criterio de manera tal que no exista
 ningún camino de un nodo en un componente fuertemente conexo hacia un nodo
 de un componente fuertemente conexo que aparezca después en la secuencia.
\end_layout

\begin_layout Standard
Si estos componentes fuertemente conexos son identificados en el orden mostrado
 en el párrafo anterior, y los nodos de 
\begin_inset Formula $C_{1}$
\end_inset

son numerados antes de los nodos de 
\begin_inset Formula $C_{2}$
\end_inset

, y así sucesivamente, entonces la matriz asociada es triangular de a bloques
 donde los bloques se corresponden con los componentes fuertemente conexos
 del grafo.
 Además, dado que el subgrafo asociado con cada submatriz de la diagonal
 en la forma de a bloques es fuertemente conexo, es evidente que los bloques
 no pueden ser permutados a la forma BLT.
\end_layout

\begin_layout Standard
En 
\begin_inset CommandInset citation
LatexCommand citep
key "Duff:1978:ITA:355780.355785"

\end_inset

 Duff presenta dos algoritmos que exiben esta propiedad en donde los componentes
 fuertemente conexos son identificados en un orden tal que los nodos de
 cada componente pueden poseer caminos que conducen a nodos de componentes
 previos pero nunca a nodos de componentes posteriores.
 Estos algoritmos son el de Sargent and Westerber y el de Tarjan.
 Mientras el algoritmo de Sargent and Westerber presenta una complejidad
 temporal en el peor caso de 
\begin_inset Formula $O(n^{2})$
\end_inset

 el algoritmo de Tarjan se ejecuta en 
\begin_inset Formula $O(n)+O(\tau)$
\end_inset

 donde 
\begin_inset Formula $\tau$
\end_inset

 es la cantidad de entradas de la matriz que no pertenecen a la diagonal
 y son diferentes de 0.
\end_layout

\begin_layout Subsubsection
Algoritmo de Tarjan para encontrar los componentes fuertemente conexos de
 un grafo
\end_layout

\begin_layout Standard
El algorítmo de tarjan es un algoritmo perteneciente a la teoria de grafos.
 Dicho algoritmo permite encontrar los componentes fuertemente conexos en
 un grafo dirigido 
\begin_inset CommandInset citation
LatexCommand citep
key "Tarjan72"

\end_inset

.
\end_layout

\begin_layout Standard
El algoritmo recibe como entrada un grafo dirigido y produce una partición
 de los vértices del grafo en componentes fuertemente conexos.
 Cada vértice del grafo aparece en un solo componente fuertemente conexo.
 Un vértice que no pertenece a ningún ciclo constituye por si solo un componente
 fuertemente conexo.
\end_layout

\begin_layout Standard
La idea básica del algoritmo es la siguiente: comezando por cualquier nodo
 se realiza una búsqueda en profundidad (y subsiguientes búsquedas se realizan
 sobre cualquier nodo que no haya sido visitado aún).
 Como es usual en las búsquedas en profundidad, el proceso de búsqueda visita
 cada nodo una sola vez y rechaza visitar un nodo que ya fue explorado.
 En consecuencia la colección de árboles de búsqueda es un bosque recubridor
 del grafo.
 Los componentes fuertemente conexos se van a obtener a partir de algunos
 subárboles del bosque recubridor.
 Las raices de estos árboles seran las raices de los componentes fuertemente
 conexos.
 Cualquier nodo de un componente fuertemente conexo puede ser el nodo raiz
 siempre y cuando haya sido el primer nodo en ser descubierto para ese component
e.
\end_layout

\begin_layout Standard
Los nodos se van almacenando en una pila en el orden en el que se van encontrand
o.
 Cuando el proceso de búsqueda en profundidad recursivamente explora un
 nodo v y sus descendientes, dichos nodos no nesariamente son retirados
 (popped) de la pila antes de que la llamada recursiva termine.
 La propiedad invariante fundamental es que un nodo permanece en la pila
 después de ser explorado si y solo si posee un camino (path) hacia un nodo
 ingresado previamente en la pila.
\end_layout

\begin_layout Standard
Al final de la llamada que explora v y sus descendientes sabemos si v posee
 algún camino hacia un nodo ingresado previamente en la pila.
 De ser así la llamada retorna dejando el vértice v en la pila para preservar
 el invariante.
 En caso contrario v debe ser la raiz de su componente fuertemente conexo
 el cual consiste en v más cualquier nodo colocado posteriormente.
 El componente identificado se retira de la pila.
\end_layout

\begin_layout Standard
A cada nodo v se le asigna un entero único 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.index+
\end_layout

\end_inset

 el cual numera los nodos de manera consecutiva en el orden en el que son
 descubiertos.
 Además para cada nodo también se mantiene un valor denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink+
\end_layout

\end_inset

 el cual representa el menor índice asociado a un nodo accesible desde v,
 incluido el mismo v.
 De esta manera v debe ser mantenido en la pila si 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink < v.index+
\end_layout

\end_inset

, y v debe ser removido de la pila si 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink == v.index+
\end_layout

\end_inset

.
 El valor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+v.lowlink+
\end_layout

\end_inset

 es calculado durante la búsqueda en profundidad originada en v.
 
\end_layout

\begin_layout Standard
A continuación vemos el algoritmo en pseudo-código:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

algorithm tarjan is
\end_layout

\begin_layout Plain Layout

  input: graph G = (V, E)
\end_layout

\begin_layout Plain Layout

  output: set of strongly connected components (sets of vertices) 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  index := 0 
\end_layout

\begin_layout Plain Layout

  S := empty
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for each v in V do
\end_layout

\begin_layout Plain Layout

    if (v.index is undefined) then
\end_layout

\begin_layout Plain Layout

      strongconnect(v)
\end_layout

\begin_layout Plain Layout

    end if
\end_layout

\begin_layout Plain Layout

  end for
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  function strongconnect(v)
\end_layout

\begin_layout Plain Layout

    // Set the depth index for v to the smallest unused index
\end_layout

\begin_layout Plain Layout

    v.index := index
\end_layout

\begin_layout Plain Layout

    v.lowlink := index
\end_layout

\begin_layout Plain Layout

    index := index + 1
\end_layout

\begin_layout Plain Layout

    S.push(v)
\end_layout

\begin_layout Plain Layout

    v.onStack := true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Consider successors of v
\end_layout

\begin_layout Plain Layout

    for each (v, w) in E do
\end_layout

\begin_layout Plain Layout

      if (w.index is undefined) then
\end_layout

\begin_layout Plain Layout

        // Successor w has not yet been visited;
\end_layout

\begin_layout Plain Layout

        strongconnect(w)
\end_layout

\begin_layout Plain Layout

        v.lowlink  := min(v.lowlink, w.lowlink) 
\end_layout

\begin_layout Plain Layout

      end if
\end_layout

\begin_layout Plain Layout

    end for
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    // If v is a root node, pop the stack and generate an SCC
\end_layout

\begin_layout Plain Layout

    if (v.lowlink = v.index) then
\end_layout

\begin_layout Plain Layout

      start a new strongly connected component
\end_layout

\begin_layout Plain Layout

      repeat
\end_layout

\begin_layout Plain Layout

        w := S.pop()
\end_layout

\begin_layout Plain Layout

        w.onStack := false
\end_layout

\begin_layout Plain Layout

        add w to current strongly connected component
\end_layout

\begin_layout Plain Layout

      until (w = v)
\end_layout

\begin_layout Plain Layout

      output the current strongly connected component
\end_layout

\begin_layout Plain Layout

    end if
\end_layout

\begin_layout Plain Layout

  end function
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

Aplicación del algoritmo de Tarjan para obtener la forma BLT
\end_layout

\begin_layout Standard
En esta sección vamos explicar como aplica el algorítmo de Tarjan en la
 transformación a la forma triangular inferior de a bloques de la matriz
 asociada a un sistema de ecuaciones algebraicas.
\end_layout

\begin_layout Standard
Para explicar el algoritmo vamos a utilizar el sistema de ecuaciones diferencial
es algebraicas que aparece en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:pre_tarjan}
\end_layout

\end_inset

 junto con su matriz de adyacencia asociada.
 La matriz de adyacencia posee una fila por cada ecuación y una columna
 por cada incógnita.
 Una entrada (i,j) de la matriz toma el valor 1 si la variable j ocurren
 en la ecuación i.
 En caso contrario la entrada de la matriz es 0.
 La figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:grafo_pre_tarjan}
\end_layout

\end_inset

 muestra el grafo bipartito asociado al sistema de ecuaciones.
 La forma BLT final del sistema de ecuaciones, la cual es el resultado esperado
 de la transformación BLT, aparece en la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:post_tarjan}
\end_layout

\end_inset

 incluyendo un pequeño componente fuertemente conexo, un bloque compuesto
 por las ecuaciones f
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

y f
\begin_inset script subscript

\begin_layout Plain Layout
5
\end_layout

\end_inset

, que también se denomina bucle algebraico.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{align*}
\end_layout

\begin_layout Plain Layout

    f_1(z_3,z_4) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_2(z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_3(z_2,z_3,z_5) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_4(z_1,z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_5(z_1,z_3,z_5) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
end{align*}
\end_layout

\begin_layout Plain Layout

  
\backslash
bordermatrix{
\end_layout

\begin_layout Plain Layout

    & z_1 & z_2 & z_3 & z_4 & z_5 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 0   & 0   & 1   & 1   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 0   & 1   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 0   & 1   & 1   & 0   & 1 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 1   & 1   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 1   & 0   & 1   & 0   & 1 
\backslash
cr
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
subcaption{Sistema de ecuaciones junto con la matriz de adjacencia asociada.
\backslash
label{fig:pre_tarjan}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{align*}
\end_layout

\begin_layout Plain Layout

    f_2(z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_4(z_1,z_2) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_3(z_2,z_3,z_5) &= 0 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

    f_5(z_1,z_3,z_5) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    f_1(z_3,z_4) &= 0 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
end{align*}
\end_layout

\begin_layout Plain Layout

  
\backslash
bordermatrix{
\end_layout

\begin_layout Plain Layout

    & z_1 & z_2 & z_3 & z_4 & z_5 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 1   & 0   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 1   & 1   & 0   & 0   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 1   & 0   & 1   & 1   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 0   & 1   & 1   & 1   & 0 
\backslash
cr
\end_layout

\begin_layout Plain Layout

    & 0   & 0   & 1   & 0   & 1 
\backslash
cr
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
subcaption{Sistema de ecuaciones en la forma BLT luego de haber sido ordenado
 topológicamente por el algorítmo de Tarjan.
\backslash
label{fig:post_tarjan}}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
hfill
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{subfigure}[b]{0.3
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
includegraphics[width=
\backslash
textwidth]{graphics/bipartito_tarjan.png}
\end_layout

\begin_layout Plain Layout

   
\backslash
caption{Grafo bipartito correspondiente a la forma inicial del sistema de
 eucaciones.}
\end_layout

\begin_layout Plain Layout

   
\backslash
label{fig:grafo_pre_tarjan}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:aplicacion_tarjan}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dado que el algoritmo de tarjan aplica sobre un grafo dirigido es necesario
 asociar con el grafo bipartito, obtenido a partir del sistema de ecuaciones,
 el cual es no dirigido, un grafo dirigido.
\end_layout

\begin_layout Standard
El grafo dirigido lo construimos de la siguiente manera:
\end_layout

\begin_layout Itemize
Calculamos un emparejamiento
\begin_inset Foot
status open

\begin_layout Plain Layout
Del termino ingles 
\begin_inset Quotes eld
\end_inset

matching
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 máximo sobre el grafo original.
\end_layout

\begin_layout Itemize
Los vértices correspondientes a incógnitas se colapsan contra su pareja
 correspondiente en el conjunto de vértices asociados a ecuaciones.
\end_layout

\begin_layout Itemize
Las aristas que no pertenecen al emparejamiento se reemplazan por aristas
 dirigidas entrantes en los vértices correspondientes a incógnitas.
\end_layout

\begin_layout Standard
En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:nodirigido2dirigido}
\end_layout

\end_inset

 se puede ver como se obtiene el grafo dirigido a partir del grafo no dirigido.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{
\backslash
label{fig:nodirigido2dirigido}}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finalmente aplicamos el algoritmo de Tarjan ...
\end_layout

\begin_layout Chapter
Visión general del Compilador
\end_layout

\begin_layout Standard
El compilador modelicacc se desarrollo como un conjunto de componentes independi
entes, cada uno de los cuales implementa una etapa diferente del proceso
 de compilación de un programa modelica.
 En este capítulo vamos a introducir los diferentes componentes que conforman
 el compilador modelica explicando el rol de cada uno y como se conjugan
 para lograr la compilación de un programa modelica.
\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
La compilación de un modelo modelica es el proceso mediante el cual se transform
a un modelo de alto nivel, el cual puede contener clases y ecuaciones acausales,
 en un modelo plano, sin clases, y donde las ecuciones se encuentran ordenadas
 o causalizadas.
 Un modelo plano con las ecuaciones ordenadas de manera tal que para cada
 ecuación las variables del lado derecho se pueden considerar conocidas
 es un modelo apropiado para la generación de código C (o de cualquier otro
 lenguaje similar) y su posterior simulación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout

  
\backslash
centering
\end_layout

\begin_layout Plain Layout

  
\backslash
includegraphics[width=0.3
\backslash
textwidth]{graphics/BouncingBall.png}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{Bouncing Ball}
\end_layout

\begin_layout Plain Layout

  
\backslash
label{fig:bouncing_ball}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como ya mencionamos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementación-y-ejecución"

\end_inset

 el proceso de compilación consiste en primer lugar en un análisis sintáctico
 y semántico.
 Luego se realiza un aplanado del modelo obteniendo un modelo equivalente
 sin clases y con las ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 convertidas en ecuaciones comunes.
 Luego las ecuaciones acausales del modelo aplanado se causalizan ordenandolas
 topológicamente de acuerdo a las dependencias del flujo de datos entre
 ellas.
\end_layout

\begin_layout Standard
El proceso de análisis sintáctico, semántico y aplanado es responsabilidad
 de un componente denominado flatter.
 La causalización del conjunto de ecuaciones del modelo es tarea de un component
e denominda causalize.
 En las siguientes secciones vamos a describir con más detalle cada una
 de estos componentes.
\end_layout

\begin_layout Standard
Para ayudar a comprender las transformaciones que realizan sobre un modelo
 modelica los diferentes components vamos a utilizar un ejemplo.
 El ejemplo es el modelo orientado a objetos de un sistema mecánico.
 El sistema es una pelota que rebota.
 En la figura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:bouncing_ball}
\end_layout

\end_inset

 se pueden ver gráficamente el modelo.
 El mismo consta de una pelota conectada a un amortiguador el cual a su
 vez se conecta al suelo.
 El componente amortiguador, el cual obviamente en la realidad no existe,
 es necesario para representar la capacidad de rebotar de la pelota.
\end_layout

\begin_layout Standard
A continuación vemos el código modelica correspondiente al modelo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

package Example
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  connector Flange
\end_layout

\begin_layout Plain Layout

    flow Real f;
\end_layout

\begin_layout Plain Layout

    Real s;
\end_layout

\begin_layout Plain Layout

    Real v;
\end_layout

\begin_layout Plain Layout

  end Flange;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Ball
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    Real v;
\end_layout

\begin_layout Plain Layout

    parameter Real m = 1, g = 9.8;
\end_layout

\begin_layout Plain Layout

    Real y;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    der(y) = v;
\end_layout

\begin_layout Plain Layout

    flange1.v = v;
\end_layout

\begin_layout Plain Layout

    y = flange1.s;
\end_layout

\begin_layout Plain Layout

    m * der(v) = flange1.f - m * g;
\end_layout

\begin_layout Plain Layout

  end Ball;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Spring
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    Example.Flange flange2;
\end_layout

\begin_layout Plain Layout

    Real dy;
\end_layout

\begin_layout Plain Layout

    Real dv;
\end_layout

\begin_layout Plain Layout

    parameter Real b = 10, k = 10000;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    dv = flange1.v - flange2.v;
\end_layout

\begin_layout Plain Layout

    dy = flange1.s - flange2.s;
\end_layout

\begin_layout Plain Layout

    flange1.f = if dy < 0 then b * dv + k * dy else 0;
\end_layout

\begin_layout Plain Layout

    flange2.f = -flange1.f;
\end_layout

\begin_layout Plain Layout

  end Spring;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model Fixed
\end_layout

\begin_layout Plain Layout

    Example.Flange flange1;
\end_layout

\begin_layout Plain Layout

    parameter Real s0 = 0;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    flange1.s = s0;
\end_layout

\begin_layout Plain Layout

    flange1.v = 0;
\end_layout

\begin_layout Plain Layout

  end Fixed;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Example.Ball ball(y(start = 10));
\end_layout

\begin_layout Plain Layout

    Example.Spring spring;
\end_layout

\begin_layout Plain Layout

    Example.Fixed fixed;
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    connect(fixed.flange1, spring.flange2);
\end_layout

\begin_layout Plain Layout

    connect(ball.flange1, spring.flange1);
\end_layout

\begin_layout Plain Layout

  end BouncingBall;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El primer modelo del paquete es un conector que denominamos 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

.
 Los conectores modelica especifican la interfaz mediante la cual un componente
 interactua con su entorno.
 El componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 declara tres variables que representan la fuerza, la posición y la velocidad
 en un punto de la interacción.
\end_layout

\begin_layout Standard
Luego tenemos otro modelo, denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

, el cual representa la pelota.
 Este modelo declara tres variables y dos constantes.
 La primer variable es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 y representa la interfaz mediante la cual la pelota se conecta con su entorno;
 en nuestro caso con el amortiguador.
 Las otras dos variables representan la velocidad y la posición de la pelota.
 Las constantes representan la masa de la pelota y la fuerza de gravedad.
\end_layout

\begin_layout Standard
El modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 además de las variables declara un conjunto de ecuaciones las cuales definen
 el comportamiento del objeto en cada instante de tiempo.
 La primer ecuación expresa que la velocidad es equivalente a la derivada
 temporal de la posición.
 La segunda ecuación establece que la velocidad de la pelota siempre es
 la misma que la de su conector.
 La tercer ecuación expresa que la posición de la pelota siempre es la misma
 que la de su conector.
 La última ecuación corresponde a la primer ley de Newton.
\end_layout

\begin_layout Standard
El siguiente modelo declarado en el paquete, denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

, es el amortiguador.
 Este modelo declara dos conectores mediante variables de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

.
 El primer conector sera utilizado para conectar el amortiguador a la pelota
 mientras que el segundo el amortiguador al piso.
 También declara dos variables de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

, una representa la diferencia de posición entre ambos conectores y la otra
 la diferencia de velocidad.
 Por último el modelo declara dos parámetros (constantes) de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+b+
\end_layout

\end_inset

 correspondiente a la masa del amortiguador y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+k+
\end_layout

\end_inset

 correspondiente a la rigidez.
\end_layout

\begin_layout Standard
Las dos primeras ecuaciones del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

 expresan que las variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dv+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dy+
\end_layout

\end_inset

 son equivalentes a la diferencia de velocidad y a la diferencia de posición
 de los conectores respectivamente.
 La tercer ecuación establece cual es la fuerza que ejerce el amortiguador
 cuando la pelota 
\begin_inset Quotes eld
\end_inset

toca el piso
\begin_inset Quotes erd
\end_inset

, es decir cuando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+dy < 0+
\end_layout

\end_inset

.
 La última ecuación se corresponde con la ley de acción y reacción de Newton.
\end_layout

\begin_layout Standard
El último componente de nuestro sistema es el piso el cual se encuentra
 representado por el modelo denominado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Fixed+
\end_layout

\end_inset

.
 Este modelo declara una variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Flange+
\end_layout

\end_inset

 que representa el conector del componente y una constante de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Real+
\end_layout

\end_inset

 incializada a cero que representa la posición del componente.
 Las dos ecuaciones del modelo establecen que tanto la posición como la
 velocidad del conector son siempre 0.
\end_layout

\begin_layout Standard
El sistema completo esta representado por el último modelo, el modelo denominado
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

.
 Este modelo declara tres variables, la primera de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 representa la pelota.
 Notar que cuando se declara la variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 se incializa la variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+y+
\end_layout

\end_inset

 la cual representa la posición.
 El valor asignado a dicha variable es el valor que va a tomar al inicio
 de la simulación.
 Luego de la variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Ball+
\end_layout

\end_inset

 se declara una variable de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Spring+
\end_layout

\end_inset

 representado el amortiguador.
 La tercer variable que declara el modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Fixed+
\end_layout

\end_inset

 y representa el suelo.
\end_layout

\begin_layout Standard
En la sección 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+equation+
\end_layout

\end_inset

 del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 se incluyen dos expresiones de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

.
 Estas dos expresiones establecen que la pelota se ecuentra conectada al
 amortiguador y que el amortiguador se encuentra conectado al suelo.
\end_layout

\begin_layout Section
Análisis sintáctico, semántico y aplanado: flatter
\end_layout

\begin_layout Standard
El modelo que vemos a continuación es equivalente al modelo anterior solo
 que las clases fueron expandidas y las ecuaciones connect se convirtieron
 en ecuaciones comunes.
 Las dos ecuaciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+connect+
\end_layout

\end_inset

 del modelo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BouncingBall+
\end_layout

\end_inset

 se sustituyeron por las seis últimas ecuaciones que se pueden ver en el
 modelo a continuación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=modelica]
\end_layout

\begin_layout Plain Layout

  model BouncingBall
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange1_v;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_f;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

    Real spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

    Real spring1_dy;
\end_layout

\begin_layout Plain Layout

    Real spring1_dv;
\end_layout

\begin_layout Plain Layout

    parameter Real spring1_b=10;
\end_layout

\begin_layout Plain Layout

    parameter Real spring1_k=10000;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

    parameter Real fixed1_s0=0;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_f;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    Real ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

    Real ball1_v;
\end_layout

\begin_layout Plain Layout

    parameter Real ball1_m=1;
\end_layout

\begin_layout Plain Layout

    parameter Real ball1_g=9.8;
\end_layout

\begin_layout Plain Layout

    Real ball1_y(start=10);
\end_layout

\begin_layout Plain Layout

  equation
\end_layout

\begin_layout Plain Layout

    spring1_dv = spring1_flange1_v-spring1_flange2_v;
\end_layout

\begin_layout Plain Layout

    spring1_dy = spring1_flange1_s-spring1_flange2_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_f = if spring1_dy<0 then spring1_b*spring1_dv+spring1_k*spri
ng1_dy else 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_f = (-spring1_flange1_f);
\end_layout

\begin_layout Plain Layout

    fixed1_flange1_s = fixed1_s0;
\end_layout

\begin_layout Plain Layout

    fixed1_flange1_v = 0;
\end_layout

\begin_layout Plain Layout

    der(ball1_y) = ball1_v;
\end_layout

\begin_layout Plain Layout

    ball1_flange1_v = ball1_v;
\end_layout

\begin_layout Plain Layout

    ball1_y = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    ball1_m*der(ball1_v) = ball1_flange1_f-ball1_m*ball1_g;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_f+fixed1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_s = fixed1_flange1_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange2_v = fixed1_flange1_v;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_f+ball1_flange1_f = 0;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_s = ball1_flange1_s;
\end_layout

\begin_layout Plain Layout

    spring1_flange1_v = ball1_flange1_v;
\end_layout

\begin_layout Plain Layout

  end BouncingBall; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:micromodelica:"

\end_inset

Simplificación a micromodelica: mmo
\end_layout

\begin_layout Section
Causalización: causalize
\end_layout

\begin_layout Part
Contribuciones
\end_layout

\begin_layout Chapter
Implementación etapa de causalización
\end_layout

\begin_layout Standard
En este capítulo se describe la implementación de una de las etapas del
 proceso de compilación del compilador modelica descrito en el capitulo
 anterior.
 Dicha etapa es la de causalización.
 La principal tarea que se lleva a cabo en esta etapa es la aplicación del
 algoritmo de Tarjan para lograr la transformación a la forma triangular
 inferior de a bloques (o BLT) de la matriz de coeficientes asociada al
 sistema de ecuaciones diferenciales algebraicas de un modelo modelica aplanado.
 Como ya vimos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transformación-BLT--"

\end_inset

 un sistema de ecuaciones reordenado según la forma BLT de su matriz asociada
 puede ser resuelto casi secuencialmente.
 Para los subsitemas de ecuaciones que no pueden ser resueltos secuencialmente
 sino que deben ser resueltos simultaneamente, denominados bucles algebraicos,
 el algoritmo de Tarjan garantiza que su tamaño es el mínimo posible.
\end_layout

\begin_layout Standard
En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 vimos que para poder aplicar el algoritmo de Tarjan es necesario construir
 un grafo a partir de la matriz de coeficientes asociada al sistema de ecuacione
s.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Construcción-del-grafo"

\end_inset

 detallamos la estructura de datos que se utilizo para la representación
 del grafo y cómo se implemento la construcción del grafo bipartito asociado
 al sistema de ecuaciones.
\end_layout

\begin_layout Standard
La aplicación del algoritmo de Tarjan se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

.
 En esta sección además se detalla como se implemento la construcción del
 grafo dirigido a partir del grafo bipartito y se incluye un análisis de
 la complejidad temporal de todo el proceso de aplicación del algoritmo.
\end_layout

\begin_layout Standard
Por último en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

 se describe una optimización del proceso de causalización.
 La optimización consta de un algoritmo que se aplica previo al algoritmo
 de Tarjan.
 Dicho algoritmo tiene una complejidad logarítmica respecto de la cantidad
 de vértices del grafo y en el caso de modelos sin bucles algebraicos alcanza
 a ordenar todas las ecuaciones.
 La ventaja de este algorítmo respecto del algóritmo de Tarjan es que no
 requiere la construcción del grafo dirigido lo cual tienen una complejidad
 cuadrática en el peor caso (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

).
 Si el modelo posee bucles dicho algoritmo no ordena todas las ecuaciones
 pero reduce significativamente el grafo sobre el que aplica luego el algoritmo
 de Tarjan.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Construcción-del-grafo"

\end_inset

Construcción del grafo bipartito
\end_layout

\begin_layout Standard
La estructura de datos que utilizamos para representar el grafo de causalización
 así como las operaciones que aplicamos sobre dicha estructura son las que
 provee la biblioteca Boost Graph (BGL de aquí en adelante) 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Biblioteca-Boost-Graph"

\end_inset

 explicamos brevemente las diferentes representaciones de grafos que ofrece
 la BGL y cuales son las carácteristicas de cada una.
 En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Definición-del-grafo"

\end_inset

 detallamos la estructura de datos que contruimos, a partir de una de las
 representaciones de grafos de la BGL, para representar el grafo bipartito
 asociado al sistema de ecuaciones del modelo.
\end_layout

\begin_layout Standard
Una vez introducida la estructura de datos que utilizamos como representación
 para el grafo bipartito pasamos a describir el proceso de construcción
 del mismo.
 Para construir el grafo necesitamos acceder al modelo y a partir de este
 identificar las ecuaciones, las incógnitas y en que ecuación aparece cada
 incógnita.
 El modelo es representado por una objeto de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, la cual se encuentra declarada en el archivo mmo/mmo_class.h e implementada
 en el archivo mmo/mmo_class.h, constituye el valor de entrada para la etapa
 de cauzalización.
 También puede verse como la interfaz entre la etapa de causalización y
 la etapa previa (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:micromodelica:"

\end_inset

).
\end_layout

\begin_layout Standard
En general las ecuaciones son procesadas tal como se obtienen el objeto
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La única excepción son las ecuaciones de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+For-Equation+
\end_layout

\end_inset

.
 Este tipo de expresión se utiliza para describir un conjunto de ecuaciones
 que comparten cierta estructura.
 Dado que una expresión de este tipo representa en realidad varias ecuaciones
 necesitamos expandir la expresión y sustituirla en la lista de ecuaciones
 por las ecuaciones que surgen de la expansión.
 La implementación de esta tarea se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

.
 La identificación de incógnitas se realiza recorriendo la tabla de símbolos,
 que tamibién se accede via el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, y verificando si la variable cumple con las condiciones para que sea considera
da como una incógnita.
 Esta tarea se describe en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Identificación-de-incógnitas"

\end_inset

.
 Por último, para 
\begin_inset Quotes eld
\end_inset

trazar
\begin_inset Quotes erd
\end_inset

 las aristas del grafo es necesario determinar en que ecuación ocurre cada
 variable.
 La implementación de una función para dicha tarea se describe en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ocurrencia-de-una"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Biblioteca-Boost-Graph"

\end_inset

Biblioteca Boost Graph
\end_layout

\begin_layout Standard
Parte de la biblioteca Boost Graph Library (BGL) es una interfaz genérica
 que permite acceder a la estructura de un grafo, pero ocultando los detalles
 de implementación.
 Es una interfaz 
\begin_inset Quotes eld
\end_inset

abierta
\begin_inset Quotes erd
\end_inset

 en el sentido de que cualquier otra biblioteca que implemente dicha interfaz
 va a ser compatible con los algoritmos genéricos de la BGL y con cualquier
 otro algoritmo genérico que también utilice esta interfaz.
 Además de la interfaz la BGL ofrece un conjunto de representaciones de
 grafos que implementan dicha interfaz 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
\end_layout

\begin_layout Standard
Actualmente la BGL provee dos clases para representar grafos:
\end_layout

\begin_layout Itemize
adjacency_list
\end_layout

\begin_layout Itemize
adjacency_matrix
\end_layout

\begin_layout Standard
La clase adjacency_list implementa un grafo como una lista de adyacencia.
 Es una clase de propósito general altamente parametrizable.
 Puede ser optimizada para distintas situaciones: el grafo puede ser dirigido
 o no dirigido, admite o no aristas paralelas, acceso eficiente solo a las
 aristas salientes (out-edges) o también a las aristas entrantes (in-edges),
 inserción y remoción rápida de vértices pero con más consumo de espacio,
 etc.
\end_layout

\begin_layout Standard
La clase adjacency_matrix almacena aristas en una matriz de 
\begin_inset Formula $|V|\times|V|$
\end_inset

 (donde 
\begin_inset Formula $|V|$
\end_inset

 es la cantidad de vértices).
 Los elementos de esta matriz representan aristas en el grafo.
 Este tipo de representación es conveniente para los casos de grafos densos,
 o sea donde la cantidad de aristas se aproxima a 
\begin_inset Formula $|V|^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
La ventaja de la adjacency_matrix por sobre la adjacency_list es que la
 inserción y eliminación de aristas se realiza en tiempo constante.
 No obstante hay varias desventajas.
 La primera es que la cantidad de memoria utilizada es 
\begin_inset Formula $O(V^{2})$
\end_inset

 contra 
\begin_inset Formula $O(V+E)$
\end_inset

que requiere la adjacency_list.
 La segunda es que las operaciones que recorren todas las aristas salientes
 de cada vértice demoran 
\begin_inset Formula $O(V^{2})$
\end_inset

 para la adjacency_matrix en lugar de 
\begin_inset Formula $O(V+E)$
\end_inset

 para la adjacency_list.
\end_layout

\begin_layout Standard
Ambas representaciones permiten que se adjunten objetos a los vértices y
 aristas por medio de Bundled Properties.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Definición-del-grafo"

\end_inset

Definición del grafo de causalización
\end_layout

\begin_layout Standard
El grafo sobre el cual se aplica el algoritmo de causalización es un grafo
 bipartito no dirigido, en donde uno de los conjuntos de vértices esta asociado
 a las incógnitas de un modelo y el otro esta asociado a las ecuaciones
 de dicho modelo.
 Las aristas del grafo denotan la ocurrencia de una variable en una ecuación.
 
\end_layout

\begin_layout Standard
Los grafos que representan modelos de sistemas continuos en general resultan
 ser esparcidos, es decir, poseen pocas aristas en relación a la cantidad
 de vértices 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson:2003:POM:966262"

\end_inset

.
 Por este motivo la representación que decidimos utilizar para el grafo
 es adjacency_list.
\end_layout

\begin_layout Standard
En el archivo causalize/graph_definition.h se encuentra la definición del
 tipo que utilizamos para declarar el grafo de causalización, la definición
 del tipo de los objetos que adjuntamos a los vértices y la definición de
 los tipos para los vértices y aristas del grafo.
 Estas definiciones se pueden ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct VertexProperties { MMO_EquationList eqs;
\end_layout

\begin_layout Plain Layout

                          AST_ExpressionList unknowns; };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef boost::adjacency_list<boost::listS,
\end_layout

\begin_layout Plain Layout

        boost::listS, boost::undirectedS,
\end_layout

\begin_layout Plain Layout

        VertexProperties> CausalizationGraph;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef CausalizationGraph::vertex_descriptor Vertex;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef CausalizationGraph::edge_descriptor Edge;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La estructura VertexProperties define el tipo de los objetos que adjuntamos
 a los vértices del grafo.
 Estos objetos contienen las ecuaciones o incógnitas que los vértices del
 grafo representan.
\end_layout

\begin_layout Standard
El grafo sobre el cual aplicamos el algoritmo de causalización es de tipo
 CausalizationGraph.
 El tipo CausalizationGraph resulta de instanciar el template adjacency_list
 para que se ajuste a las necesidades del algoritmo de causalización .
 Los parámetros con los que instanciamos el template se corresponden respectivam
ente con el contenedor para las aristas del grafo, el cual en nuestro caso
 es de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 es un selector de tipo para 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

), el contenedor para los vértices el cual también es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

, el tipo de grafo, que en nuestro caso es no dirigido, y finalmente el
 tipo de los objetos que se adjuntan a los vértices del grafo, el cual es
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+VertexProperties+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La elección de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 como contenedor para las aristas y vértices del grafo se justifica ya que
 con este tipo de estructura de datos la complejidad temporal de las operaciones
 que modifican el grafo es mejor 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 Por ejemplo la operacion 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+remove_vertex()+
\end_layout

\end_inset

, la cual se utiliza en la optimización del proceso de causalización (ver
 sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

), es constante para el contenedor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::listS+
\end_layout

\end_inset

 pero 
\begin_inset Formula $O(V+E)$
\end_inset

 para el contenedor 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+boost::vecS+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Vertex+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Edge+
\end_layout

\end_inset

 son los tipos de datos de los objetos que representan a los vértices y
 aristas del grafo.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Expansión-de-ecuaciones"

\end_inset

Expansión de ecuaciones de tipo For-Equation
\end_layout

\begin_layout Standard
Las For-Equation tienen la siguiente forma 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

    
\backslash
textbf{for} for_indices 
\backslash
textbf{loop}
\end_layout

\begin_layout Plain Layout

        
\backslash
{ equation ";" 
\backslash
}
\end_layout

\begin_layout Plain Layout

    
\backslash
textbf{end for} ";"
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La primer línea es lo que se denomina el prefijo de la For-Equation, el
 mismo se conforma de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

   for_indices: for_index 
\backslash
{"," for_index
\backslash
}
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout

   for_index:
\end_layout

\begin_layout Plain Layout

       IDENT [ in expression ] 
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se puede apreciar, cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 a su vez se compone de un índice, denotado por IDENT, más una expresión
 la cual define el conjunto de valores que debe asumir dicho índice.
\end_layout

\begin_layout Standard
Hay dos aspectos de las For-Equations que no fueron contemplados en esta
 primer implementación.
 Uno es la posibilidad de definir más de un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

, lo cual es equivalente a escribir 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 anidados.
 El otro tiene que ver con la posibilidad de definir un rango de iteración
 implícito, es decir un 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 sin la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+in expression+
\end_layout

\end_inset

.
 Estos aspectos quedan pendientes para una próxima versión.
\end_layout

\begin_layout Standard
La expanción de las For-Equations existentes en un modelo es responsabilidad
 de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equations+
\end_layout

\end_inset

 declarada en el archivo causalize/for_unrolling/process_for_equations.h.
 El prototipo de la función es el siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void process_for_equations(MMO_Class mmo_class);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La función recibe un modelo y modifica la lista de ecuaciones declaradas
 en dicho modelo eliminando las For-Equations y agregando las nuevas ecuaciones
 que resulten de la expansión de cada For-Equation.
\end_layout

\begin_layout Standard
El primer paso para expandir una For-Equation es procesar el prefijo para
 obtener el conjuntos de valores que deben tomar los índices de cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 Como dijimos anteriormente en esta implementación solo se soportan For-Equation
s con un solo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 en el prefijo el cual a su vez debe incluir la expresión que define el
 rango, es decir no estan soportados los rangos implícitos.
 Por lo tanto procesar el prefijo implica evaluar la expresión del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 Una vez obtenido el conjunto de valores que debe asumir el índice se procede
 a instanciar las ecuaciones declaradas dentro de la For-Equation para cada
 valor del conjunto.
 Si dentro de la For-Equation hay declaradas m ecuaciones y la cantidad
 de valores del conjunto obtenido al evaluar la expresión es n el conjunto
 de nuevas ecuaciones que se agregan al modelo es m * n.
\end_layout

\begin_layout Subsubsection
Procesamiento de la expresión del índice
\end_layout

\begin_layout Standard
La expresión de cada 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 debe ser de tipo vector y a su vez debe ser una expresión constante 
\begin_inset CommandInset citation
LatexCommand citep
key "Fritzson98"

\end_inset

.
 Un Vector es un array de dimensión 1.
 Una expresión constante es una expresión formada por elementos constantes,
 es decir que no varían respecto del tiempo.
 Los vectores se pueden construir utilizando el operador brace 
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset

, el operador colon 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 o una combinación de ambos.
 Ejemplos de expresiones de tipo vector son:
\end_layout

\begin_layout Itemize
{1, 2, 3, 4}
\end_layout

\begin_layout Itemize
j : k equivalente al vector de enteros {j, j+1, ..., k}, siempre y cuando j
 y k sean enteros
\end_layout

\begin_layout Itemize
j : d : k equivalente al vector de enteros {j, j+d, ..., j+n*d}, con n = (k
 – j)/d, si j, d, y k son de tipo entero.
\end_layout

\begin_layout Standard
Para poder implementar la rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equations+
\end_layout

\end_inset

 de manera independiente de la forma de la expresión del prefijo del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 decidimos definir una interfaz que capture la idea de un iterador.
 La rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equation+
\end_layout

\end_inset

 utilizando esta interfaz itera a través de los valores definidos por la
 expresión del prefijo de la For-Equation.
 Esta interfaz esta declarada en el archivo causalize/for_unrolling/for_index_it
erator.h y tiene la siguiente forma:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

class ForIndexIterator {
\end_layout

\begin_layout Plain Layout

  public:
\end_layout

\begin_layout Plain Layout

    virtual bool hasNext() = 0;
\end_layout

\begin_layout Plain Layout

    virtual AST_Real next() = 0;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hay dos clases que implementan esta interfaz, RangeIterator y BraceIterator,
 asociadas a los dos tipos de expresiones que se pueden encontrar en un
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

.
 La declaración de estas clases también se encuentra en el archivo causalize/for
_unrolling/for_index_iterator.h y la implementación en el archivo causalize/for_u
nrolling/for_index_iterator.cpp.
\end_layout

\begin_layout Subsubsection
Instanciación de ecuaciones
\end_layout

\begin_layout Standard
La rutina 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+process_for_equation+
\end_layout

\end_inset

 en cada iteración (sobre el rango definido en el 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

) instancia las ecuaciones declaradas en la For-Equation con el valor que
 toma la variable del 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for_index+
\end_layout

\end_inset

 en esa iteración.
 Para realizar la instanciación fue necesario escribir una clase que permita
 realizar la evaluación algebraica de una expresión.
 Esta clase es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+EvalExp+
\end_layout

\end_inset

, su declaración se puede encontrar en el archivo util/ast_visitors/evalexp.h
 y su implementación en el archivo util/ast_visitors/evalexp.cpp.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Identificación-de-incógnitas"

\end_inset

Identificación de incógnitas
\end_layout

\begin_layout Standard
Para poder construir el grafo sobre el cual se aplica el algoritmo de causalizac
ión es necesario identificar cuales de todas las variables declaradas en
 el modelo son incógnitas y cuales no.
 Una variable es una incógnita si satisface las siguientes condiciones:
\end_layout

\begin_layout Itemize
Es una variable continua.
 Es decir que varia de manera continua respecto del tiempo.
\end_layout

\begin_layout Itemize
No es un estado.
 Un variable es un estado si aparece su derivada en función del tiempo.
\end_layout

\begin_layout Standard
La clase encargada de identificar y recolectar las incógnitas es UnknownsCollect
or definida en el archivo causalize/unknowns_collector.h.
 Esta clase recibe como parámetro de su constructor la instancia del modelo
 que se esta causalizando, es decir un objeto de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

.
 La interfaz de la clase esta compuesta por un único método con la siguiente
 firma:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  AST_ExpressionList collectUnknowns();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El procedimiento para identificar las incógnitas es bastante sencillo.
 Como primer paso se identifican las variables que son estados.
 Luego se recorre la tabla de símbolos, a la cual se accede a partir del
 objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+MMO_Class+
\end_layout

\end_inset

, y para cada variable se verifican las condiciones presentadas anteriormente,
 que sea continua y que no sea un estado.
 Si la variable satisface las condiciones se la agrega a la lista de incógnitas.
\end_layout

\begin_layout Standard
El proceso de identificación de estados es responsabiliad de la clase StateVaria
blesFinder declarada en el archivo causalize/state_variables_finder.h.
 De la misma manera que el UnkownsCollector esta clase recibe como parámetro
 de su constructor la instancia del modelo que se esta causalizando.
 Su interfaz esta compuesta por un único método cuya firma es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void findStateVariables();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este método recorre la estructura de las ecuaciones del modelo en busca
 de derivadas.
 Cada vez que encuentra una expresión de este tipo marca en la tabla de
 símbolos la variable, sobre la cual se aplica la derivada, como estado.
 En esta versión del algoritmo, y por una cuestión de simplicidad, solo
 están soportadas derivadas de una sola variable.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ocurrencia-de-una"

\end_inset

Ocurrencia de una incógnita en una ecuación
\end_layout

\begin_layout Standard
Cada arista del grafo de causalización se corresponde con la ocurrencia
 de una incógnita en una ecuación.
 Para poder construir el grafo necesitamos una manera de determinar si una
 incógnita pertenece a una ecuación.
 Para resolver esto escribimos un visitor, es decir, una clase que implementa
 el patrón de diseño Visitor.
 La clase es 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+contains+
\end_layout

\end_inset

 y se puede encontrar en el archivo util/ast_visitors/contains.h.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reescribir
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sub:Aplicación-Tarjan-Boost"

\end_inset

Aplicación del algoritmo de Tarjan
\end_layout

\begin_layout Standard
En la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 explicamos el algoritmo de tarjan y de que forma aplica dicho algoritmo
 al problema de causalización de un sistema de ecuaciones diferenciales
 algebraicas.
 Vimos que para poder aplicar el algoritmo es necesario obtener un grafo
 dirigido a partir del grafo no dirigido asociado al sistema de ecuaciones.
 Este grafo dirigido lo obtenemos aplicando los pasos enumerados en la sección
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicacion-Tarjan-Marco-Teorico"

\end_inset

 y que aquí recordamos:
\end_layout

\begin_layout Enumerate
Calculamos un matching máximo sobre el grafo original.
\end_layout

\begin_layout Enumerate
Los vértices correspondientes a incógnitas se colapsan contra su pareja
 correspondiente en el conjunto de vértices asociados a ecuaciones.
\end_layout

\begin_layout Enumerate
Las aristas que no pertenecen al emparejamiento se reemplazan por aristas
 dirigidas entrantes en los vértices correspondientes a incógnitas.
\end_layout

\begin_layout Standard
Estos conceptos fueron implementados en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 declarada en el archivo causalize/apply_tarjan.h.
 La firma de la función es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  int apply_tarjan(CausalizationGraph &graph, std::map<int, causalize::Component
> &components);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+causalize::Component+
\end_layout

\end_inset

 representa un componenten fuertemente conexo.
 Este se encuentra definido en el mismo archivo que la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 y se declaro de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  namespace causalize {
\end_layout

\begin_layout Plain Layout

    struct _Component {
\end_layout

\begin_layout Plain Layout

      std::list<Vertex> *uVertices;
\end_layout

\begin_layout Plain Layout

      std::list<Vertex> *eqVertices;
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    typedef _Component *Component;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La estructura 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_Component+
\end_layout

\end_inset

 posee dos listas de vértices, una lista corresponde a los vértices de un
 componente fuertemente conexo asociados a ecuaciones del modelo, la otra
 lista corresponde los vértices del mismo componente fuertemente conexo
 asociados a incógnitas del modelo.
\end_layout

\begin_layout Standard
La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 declara dos argumentos.
 El primero es el grafo sobre el cual se va a aplicar el algoritmo de tarjan.
 El segundo argumento es una referencia a un diccionario o mapa ordenado
 donde las clave son índices y los valores son componententes fuertemente
 conexos representados por objetos de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+Component+
\end_layout

\end_inset

.
 Dicho diccionario sera populado con los componentes fuertemente conexos
 identificados por el algoritmo de Tarjan.
 Los índices corresponden a los identificadores que le asigna el algoritmo
 a cada componente conforme lo va encontrando.
 El valor de retorno de la función es la cantidad de componentes fuertemente
 conexos encontrados.
\end_layout

\begin_layout Standard
La implementación de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 se realizo en el archivo causalize/apply_tarjan.cpp.
 Para calcular el matching sobre el grafo no dirigido utilizamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

 provista por la Boost Graph Library 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 Una vez obtenido el matching construimos el grafo dirigido siguiendo los
 pasos descritos anteriormente.
 Luego se aplica la función provista por la BGL 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

, la cual implementa el algoritmo de Tarjan, sobre el grafo dirigido.
 Finalmente se popula el diccionario 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

 a partir del resultado arrojado por la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:ComplejidadTarjan1"

\end_inset

Complejidad
\end_layout

\begin_layout Standard
En la siguiente descripción de la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 utilizamos 
\begin_inset Formula $O(\dfrac{E}{V})$
\end_inset

 para expresar la complejidad temporal de las operaciones que recorren la
 lista de adjacencia de un vértice.
 La expresión 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 representa la cantidad promedio de aristas por vértice.
 En el peor caso la longitud de la lista de adjancencia de un vértice es
 
\begin_inset Formula $V$
\end_inset

.
 Para los casos de grafos esparcidos (o poco densos) 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 es mucho más chico que 
\begin_inset Formula $V$
\end_inset

 y puede ser considerado constante 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 En nuestro caso los grafos, que surgen de la matriz de coeficientes de
 un modelo modelica aplanado, suelen ser esparcidos 
\begin_inset CommandInset citation
LatexCommand citep
key "elmqvist2005"

\end_inset

 por lo tanto podemos asumir 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 constante en nuestros cálculos.
\end_layout

\begin_layout Standard
Las cuatro tareas que definen la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 son el cálculo del matching mediante la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

, la construcción del grafo dirigido, la aplicación del algoritmo de Tarjan
 implementado por la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 y la construcción del objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Como se puede corroborar aquí 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

 la complejidad de las funciones 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+checked_edmonds_maximum_cardinality_matching+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 son 
\begin_inset Formula $O(V\times E\times4)$
\end_inset

 y 
\begin_inset Formula $O(V+E)$
\end_inset

 respectivamente.
 Considerando que en nuestro caso el grafo es bipartito tenemos que 
\begin_inset Formula $E\geqslant\dfrac{V}{2}$
\end_inset

 por lo tanto la complejidad del cálculo del matching es 
\begin_inset Formula $O(V^{2})$
\end_inset

.
\end_layout

\begin_layout Standard
Para que se entienda mejor el calculo del costo temporal de la construcción
 del grafo dirigido vamos a mostrar el fragmento de código (extraido del
 archivo causalize/apply_tarjan.cpp) que realiza dicha tarea.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

void buildCollapsedGraph(CausalizationGraph& graph, DirectedGraph& digraph)
 {
\end_layout

\begin_layout Plain Layout

  // Create the vertices on the directed graph
\end_layout

\begin_layout Plain Layout

  CausalizationGraph::vertex_iterator vi, vi_end;
\end_layout

\begin_layout Plain Layout

  for(boost::tie(vi,vi_end) = vertices(graph); vi != vi_end; ++vi) {
\end_layout

\begin_layout Plain Layout

    if (graph[*vi].type == E) {
\end_layout

\begin_layout Plain Layout

      DGVertex v = add_vertex(digraph);
\end_layout

\begin_layout Plain Layout

      _collapsed2original[v]=*vi;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Create the edges on the directed graph
\end_layout

\begin_layout Plain Layout

  DirectedGraph::vertex_iterator vj, vj_end;
\end_layout

\begin_layout Plain Layout

  for(boost::tie(vj,vj_end) = vertices(digraph); vj != vj_end; ++vj) {
\end_layout

\begin_layout Plain Layout

    CausalizationGraph::out_edge_iterator ek, ek_end;
\end_layout

\begin_layout Plain Layout

    Vertex originalEqVertex = _collapsed2original[*vj];
\end_layout

\begin_layout Plain Layout

    Vertex uMatchingVertex = _matching[originalEqVertex];
\end_layout

\begin_layout Plain Layout

    for(boost::tie(ek,ek_end) = out_edges(uMatchingVertex, graph); ek !=
 ek_end; ++ek) {
\end_layout

\begin_layout Plain Layout

        Vertex eqAdjacentVertex = target(*ek, graph);
\end_layout

\begin_layout Plain Layout

        if(eqAdjacentVertex != originalEqVertex) {
\end_layout

\begin_layout Plain Layout

          boost::add_edge(original2collapsed(eqAdjacentVertex), *vj, digraph);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El primer 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 que se ve en el código de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+buildCollapsedGraph+
\end_layout

\end_inset

, el cual recorre los vértices del grafo original y por cada vértice asociado
 a una ecuación (vértice de tipo 
\begin_inset Quotes eld
\end_inset

E
\begin_inset Quotes erd
\end_inset

) agrega un vértice al nuevo grafo dirigido, posee una complegidad lineal
 respecto de 
\begin_inset Formula $V$
\end_inset

, es decir 
\begin_inset Formula $O(V)$
\end_inset

.
 Esto es así dado que la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+add_vertex+
\end_layout

\end_inset

 se ejecuta en timpo amortizado constante 
\begin_inset CommandInset citation
LatexCommand citep
key "SJLA01"

\end_inset

.
 La complejidad del segundo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+for+
\end_layout

\end_inset

 se puede representar por la siguiente expresión 
\begin_inset Formula $O(V\times\dfrac{E}{V})$
\end_inset

.
 Ya que 
\begin_inset Formula $\dfrac{E}{V}$
\end_inset

 se puede asumir constante el segundo for de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+buildCollapsedGraph+
\end_layout

\end_inset

 tiene una comlejidad de 
\begin_inset Formula $O(V)$
\end_inset

.
 Podemos concluir que la construcción del grafo dirigido a partir del grafo
 no dirigo se ejecuta en tiempo lineal.
\end_layout

\begin_layout Standard
Finalmente calculamos la complejidad de la porción de código que popula
 el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+components+
\end_layout

\end_inset

, uno de los parametro de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
 A continuación vemos la porción de código mencionada la cual es parte de
 la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  for (std::map<DGVertex,int>::iterator it=vertex2component.begin(); it!=vertex2c
omponent.end(); ++it) {
\end_layout

\begin_layout Plain Layout

        DGVertex dgVertex = it->first;
\end_layout

\begin_layout Plain Layout

        int componentIndex = it->second;
\end_layout

\begin_layout Plain Layout

        Vertex eqVertex = _collapsed2original[dgVertex];
\end_layout

\begin_layout Plain Layout

        Vertex uVertex = _matching[eqVertex];
\end_layout

\begin_layout Plain Layout

        std::map<int, causalize::Component>::iterator componentsIt = components.f
ind(componentIndex);
\end_layout

\begin_layout Plain Layout

        if(componentsIt == components.end()){
\end_layout

\begin_layout Plain Layout

          causalize::Component component = new causalize::_Component;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *uVertices = new std::list<Vertex>;
\end_layout

\begin_layout Plain Layout

          uVertices->push_back(uVertex);
\end_layout

\begin_layout Plain Layout

          component->uVertices = uVertices;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *eqVertices = new std::list<Vertex>;
\end_layout

\begin_layout Plain Layout

          eqVertices->push_back(eqVertex);
\end_layout

\begin_layout Plain Layout

          component->eqVertices = eqVertices;
\end_layout

\begin_layout Plain Layout

          components[componentIndex] = component;
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          causalize::Component component = componentsIt->second;
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *uVertices = component->uVertices;
\end_layout

\begin_layout Plain Layout

          uVertices->push_back(uVertex);
\end_layout

\begin_layout Plain Layout

          std::list<Vertex> *eqVertices = component->eqVertices;
\end_layout

\begin_layout Plain Layout

          eqVertices->push_back(eqVertex);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El mapa 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+vertex2component+
\end_layout

\end_inset

 asocia a cada vértice del grafo dirigido sobre el cual aplicamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+strong_components+
\end_layout

\end_inset

 el número de componente al cual pertenece.
 La cantidad de elementos de dicho mapa es 
\begin_inset Formula $\dfrac{V}{2}$
\end_inset

.
 Dentro del bucle que itera sobre el mencionado mapa se ven operaciones
 de acceso sobre otros tres mapas ordenados que son 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_collapsed2original+
\end_layout

\end_inset

 que asocia cada vértice del grafo dirigido con un vértice del grafo original,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_matching+
\end_layout

\end_inset

 el cual contiene el matching calculado sobre el grafo original y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_components+
\end_layout

\end_inset

.
 Las cantidad de elementos de estos tres mapas son respectivamente 
\begin_inset Formula $\dfrac{V}{2}$
\end_inset

, 
\begin_inset Formula $V$
\end_inset

 y 
\begin_inset Formula $V$
\end_inset

 también para 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_components+
\end_layout

\end_inset

 en el peor caso.
 Dado que estos mapas son del tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+map+
\end_layout

\end_inset

, el tipo que representa los mapas ordenados en C++, la operación de acceso
 por clave tiene una complejidad logarítmica.
 La comlejidad de esta porción de código es 
\begin_inset Formula $O(\dfrac{V}{2}\times(\log(\dfrac{V}{2})+\log(V)+\log(V)))$
\end_inset

 lo cual es equivalente a 
\begin_inset Formula $O(V\times\log(V))$
\end_inset

.
\end_layout

\begin_layout Standard
Habiendo calculado la complejidad de cada parte de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 concluimos que la complejidad total de la función queda condicionanda por
 la complejidad del cálculo del matching la cual es cuadrática.
 Es decir, la complejidad de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 es 
\begin_inset Formula $O(V^{2})$
\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sub:Optimización"

\end_inset

Optimización del proceso de causalización
\end_layout

\begin_layout Standard
En esta sección se describe la implementación de un algoritmo simple el
 cual permite optmizar el proceso de causalización de ecuaciones.
 Dicho algorítmo resulta más óptimo que el algoritmo de Tarjan para los
 casos que no presentan búcles algebraicos.
 La característica principal es que aplica directamente sobre el grafo no
 dirigido lo cual ahorra el costo del cálculo del matching que sí es necesario
 para poder aplicar el algorítmo de Tarjan.
 El algorítmo representa una optimización del proceso en todos los casos,
 es decir inclusive en aquellos que si presentan bucles algebraicos.
 En estos casos, el algoritmo simple causaliza todas las ecuaciones que
 no se encuentren involucradas en un bucle algebraico dejando un modelo
 mucho más reducido.
 Finalmente el algoritmo de Tarjan se aplica sobre el modelo reducido resultante
 de aplicar el algoritmo simple.
\end_layout

\begin_layout Standard
El algoritmo al que nos referimos es una versión modificada de el que se
 presenta en el capítulo 
\shape italic
Differential Algebraic Equations
\shape default
 del libro 
\shape italic
Continuous System Simulation
\shape default
 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

.
 Se presenta como un algoritmo para obtener la transformación BLT de la
 matriz de coeficientes asociada a un sistema de ecuaciones diferenciales
 algebraicas.
 El algoritmo aplica sobre el grafo bipartito que se obtiene a partir del
 sistema de ecuaciones diferenciales algebraicas de la misma manera que
 lo hace la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 de la sección anterior.
 Supondiendo un grafo que admite aristas de colores y que inicialmente las
 aristas del grafo son de color negro el algoritmo se puede definir a partir
 de las siguientes reglas:
\end_layout

\begin_layout Enumerate
para cada ecuación acausal, si la ecuación posee solo una arista negra,
 coloreamos esa arista de rojo, seguimos esa arista hacia la variable que
 se encuentra en el otro extremo, y coloreamos el resto de las arista que
 salen de dicha variable con azul.
 Enumeramos la ecuación utilizando el menor número que se encuentre libre
 comenzando desde 1.
\end_layout

\begin_layout Enumerate
para cada incógnita, si posee solo una arista negra la coloreamos de rojo,
 seguimos dicha arista hasta la ecuación correspondiente y coloreamos el
 resto de las aristas de dicha ecuación en azul.
 Enumeramos la ecuación utilizando el número más alto comenzando con 
\emph on
n
\emph default
, donde 
\emph on
n
\emph default
 es el número de ecuaciones.
\end_layout

\begin_layout Standard
Una ecuación es causal si posee solo una arista roja.
 En cambio una ecuación que posee solo aristas azules o negras es una ecuación
 acausal.
 De la misma manera una variable es conocida si posee solo una arista roja
 y es una incógnita si posee solo aristas azules o negras.
 Ninguna ecuación o variable debe tener más de una arista roja.
\end_layout

\begin_layout Standard
Si el modelo no posee lazos algebraicos este algoritmo va a ser capaz de
 causalizar todas las ecuaciones.
 Esto significa que en cada vértice se conecta una y solo una arista roja.
 En el caso contrario el algoritmo va a llegar a un punto en el que las
 ecuaciones acausales y las incógnitas restantes van a poseer todas más
 de una arista con lo cual no va a ser posible aplicar ninguna de las reglas
 antes descriptas.
\end_layout

\begin_layout Standard
Tal como esta planteado el algoritmo en 
\begin_inset CommandInset citation
LatexCommand citep
key "CK06"

\end_inset

 la complejidad es cuadrática.
 Para entender porque esto es así presentamos en pseudo-código y de manera
 muy simplificada el algoritmo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  do {
\end_layout

\begin_layout Plain Layout

    for each v of [lista de ecuaciones acausales] {
\end_layout

\begin_layout Plain Layout

	    aplicar regla 1 sobre v
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

    for each v of [lista de incognitas] {
\end_layout

\begin_layout Plain Layout

	  aplicar regla 2 sobre v
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  } while (queden vertices por causalizar &&
\end_layout

\begin_layout Plain Layout

           se haya causalizado al menos un vertice en esta iteracion)
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El peor caso para este algoritmo es que se causalice un solo par ecuación-incógn
ita por iteración del bucle while.
 La cantidad de operaciones para este peor caso serian:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
V+(V-2)+((V-2)-2)+\ldots=\sum_{i=0}^{\frac{V}{2}}(V-2i)=\frac{V^{2}}{4}-\frac{V}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Revisar esta fórmula
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si modificamos el algoritmo de manera tal que no sea necesario recorrer
 todos los vértices correposndientes a ecuaciones ni todos los vértices
 correspondientes a incógnitas para obtener los que poseen una sola arista
 adjacente de color rojo podemos mejorar la complejidad temporal.
\end_layout

\begin_layout Standard
Una versión de este algoritmo modificada para ejecutarse en tiempo lineal
 se implemento como parte de la etapa de causalización.
 Esta implementación se hizo en el método 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 de la clase 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+CausalizationStrategy+
\end_layout

\end_inset

.
 La misma se encuentra declarada en el archivo causalize/causalization_strategy.h
 e implementada en el archivo causalize/causalization_strategy.cpp.
\end_layout

\begin_layout Standard
La versión implementada del algoritmo no utiliza aristas coloreadas, en
 cambio la condición para causalizar un par ecuación-incógnita es que el
 vértice posea una sola arista adjacente.
 Además una vez que se causalizo un par ecuación-incógnita se borran ambos
 vértices del grafo junto con las aristas adjacentes a ambos.
\end_layout

\begin_layout Standard
Este algoritmo se ejecuta previo a la ejecución de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
 Para los modelos que no contienen bucles algebraicos el algoritmo logra
 causalizar todas las ecuaciones sin la necesidad de ejecutar la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
 Para los modelos que si poseen bucles algebraicos el algoritmo, de complejidad
 temporal lineal, reduce significativamene la cantidad de vértices y aristas
 del grafo haciendo más eficiente la ejecución de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A continuación vemos el código de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

.
 Luego hacemos el análisis de complejidad para probar que se ejecuta en
 tiempo lineal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  void CausalizationStrategy::simpleCausalizationStrategy() { 
\end_layout

\begin_layout Plain Layout

    std::list<Vertex> eqDegree1Verts;
\end_layout

\begin_layout Plain Layout

    std::list<Vertex> unknownDegree1Verts;
\end_layout

\begin_layout Plain Layout

    CausalizationGraph::vertex_iterator vi, vi_end;
\end_layout

\begin_layout Plain Layout

    for(boost::tie(vi,vi_end) = vertices(_graph); vi != vi_end; ++vi) {
\end_layout

\begin_layout Plain Layout

	    Vertex v = *vi;
\end_layout

\begin_layout Plain Layout

	    if (out_degree(v, _graph) == 1) {
\end_layout

\begin_layout Plain Layout

            _graph[v].visited = true; 
\end_layout

\begin_layout Plain Layout

		    if (_graph[v].type == E) {
\end_layout

\begin_layout Plain Layout

			    eqDegree1Verts.push_back(v);
\end_layout

\begin_layout Plain Layout

  		  } else {
\end_layout

\begin_layout Plain Layout

	  		  unknownDegree1Verts.push_back(v);
\end_layout

\begin_layout Plain Layout

		    }
\end_layout

\begin_layout Plain Layout

  	  }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    while(!eqDegree1Verts.empty() || !unknownDegree1Verts.empty()) {
\end_layout

\begin_layout Plain Layout

        std::list<Vertex>::iterator eqIter = eqDegree1Verts.begin();
\end_layout

\begin_layout Plain Layout

        if (eqIter != eqDegree1Verts.end()) {
\end_layout

\begin_layout Plain Layout

			Vertex eq = *eqIter;
\end_layout

\begin_layout Plain Layout

			Edge e = getUniqueEdge(eq);
\end_layout

\begin_layout Plain Layout

			Vertex unknown = target(e, _graph);
\end_layout

\begin_layout Plain Layout

			makeCausalBegining(_graph[eq].eqs, _graph[unknown].unknowns);
\end_layout

\begin_layout Plain Layout

			remove_edge(e, _graph);
\end_layout

\begin_layout Plain Layout

			remove_vertex(eq,_graph);
\end_layout

\begin_layout Plain Layout

            unknownDegree1Verts.remove(unknown); 
\end_layout

\begin_layout Plain Layout

            CausalizationGraph::out_edge_iterator outEdgeIter, outEdgeIterEnd,
 next;
\end_layout

\begin_layout Plain Layout

            boost::tie(outEdgeIter, outEdgeIterEnd) = out_edges(unknown,
 _graph);
\end_layout

\begin_layout Plain Layout

            for(next = outEdgeIter; outEdgeIter != outEdgeIterEnd; outEdgeIter
 = next) {
\end_layout

\begin_layout Plain Layout

                next++;
\end_layout

\begin_layout Plain Layout

                Edge unkownAdjEdge = *outEdgeIter;
\end_layout

\begin_layout Plain Layout

                Vertex unknownAdjEq = target(unkownAdjEdge, _graph);
\end_layout

\begin_layout Plain Layout

                remove_edge(unkownAdjEdge, _graph);
\end_layout

\begin_layout Plain Layout

                if (out_degree(unknownAdjEq, _graph) == 1) {
\end_layout

\begin_layout Plain Layout

                    Edge e = getUniqueEdge(unknownAdjEq);
\end_layout

\begin_layout Plain Layout

                    Vertex eqAdjUnknown = target(e, _graph);
\end_layout

\begin_layout Plain Layout

                    if(!_graph[eqAdjUnknown].visited) {
\end_layout

\begin_layout Plain Layout

                        _graph[unknownAdjEq].visited = true;
\end_layout

\begin_layout Plain Layout

                        eqDegree1Verts.push_back(unknownAdjEq);
\end_layout

\begin_layout Plain Layout

                    }
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            remove_vertex(unknown,_graph);
\end_layout

\begin_layout Plain Layout

            eqDegree1Verts.erase(eqIter);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        std::list<Vertex>::iterator unknownIter = unknownDegree1Verts.begin();
\end_layout

\begin_layout Plain Layout

        if(unknownIter != unknownDegree1Verts.end()) {
\end_layout

\begin_layout Plain Layout

        Vertex unknown = *unknownIter;
\end_layout

\begin_layout Plain Layout

        Edge e = getUniqueEdge(unknown); 
\end_layout

\begin_layout Plain Layout

        Vertex eq = target(e, _graph);
\end_layout

\begin_layout Plain Layout

      makeCausalEnd(_graph[eq].eq, _graph[unknown].unknown);       remove_edge(e,
 _graph);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        CausalizationGraph::out_edge_iterator outEdgeIter, outEdgeIterEnd,
 next;
\end_layout

\begin_layout Plain Layout

        boost::tie(outEdgeIter, outEdgeIterEnd) = out_edges(eq, _graph);
\end_layout

\begin_layout Plain Layout

        for(next = outEdgeIter; outEdgeIter != outEdgeIterEnd; outEdgeIter
 = next) {
\end_layout

\begin_layout Plain Layout

          next++;
\end_layout

\begin_layout Plain Layout

          Edge outEdge = *outEdgeIter;
\end_layout

\begin_layout Plain Layout

          if(outEdge != e) {
\end_layout

\begin_layout Plain Layout

            Vertex eqAdjUnknown = target(outEdge, _graph);
\end_layout

\begin_layout Plain Layout

            remove_edge(outEdge, _graph);
\end_layout

\begin_layout Plain Layout

            if (out_degree(eqAdjUnknown, _graph) == 1) {
\end_layout

\begin_layout Plain Layout

              unknownDegree1Verts.push_back(eqAdjUnknown);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        makeCausalEnd(_graph[eq].eqs, _graph[unknown].unknowns);
\end_layout

\begin_layout Plain Layout

        remove_edge(e, _graph);
\end_layout

\begin_layout Plain Layout

        remove_vertex(unknown, _graph);
\end_layout

\begin_layout Plain Layout

        remove_vertex(eq, _graph);
\end_layout

\begin_layout Plain Layout

        unknownDegree1Verts.erase(unknownIter);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+simpleCausalizationStrategy+
\end_layout

\end_inset

 declara dos listas, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

.
 Estas listas contienen los vértices de grado uno asociados a ecuaciones
 en el primer caso y a incógnitas en el segundo.
\end_layout

\begin_layout Standard
La incialización de las listas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+eqDegree1Verts+
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+unknownDegree1Verts+
\end_layout

\end_inset

 la hacemos iterando sobre los vértices del grafo de causalización (el primer
 bucle for), representado por el objeto 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+_graph+
\end_layout

\end_inset

 y buscando los vértices de grado uno.
 Como ya explicamos en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ComplejidadTarjan1"

\end_inset

 la complejidad temporal de las operaciones que recorren la lista de adyacencia
 de un vértice se puede considerar constante; este es el caso de la operación
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+out_degree+
\end_layout

\end_inset

.
 Como en C++ la operación de agregar un elemento en una lista de tipo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+std::list+
\end_layout

\end_inset

 también es constante se puede concluir que la inicialización de las listas
 es un proceso que se ejecuta en tiempo lineal.
\end_layout

\begin_layout Standard
K = E/V
\end_layout

\begin_layout Standard
V + V * K es porque la operación se realiza una vez por cada vértice de
 grado uno y además por cada vértice de grado uno se realiza para cada vértice
 adyacente (K).
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Función
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cantidad invocaciones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complejidad total
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
out_degree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $K$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V+K\times V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push_back
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2\times V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
graph[]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $V+2\times K\times V$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V\times\log V)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove_vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove_edge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V+K*V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O(V)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
makeCausalBegining
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
makeCausalEnd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(V^{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "sec:Tests-unitarios"

\end_inset

Tests unitarios
\end_layout

\begin_layout Standard
Los tests unitarios se desarrollaron utilizando la biblioteca Boost Test
 
\begin_inset CommandInset citation
LatexCommand citep
key "ROTEST"

\end_inset

.
 Para cada componente que deseábamos testear escribimos un archivo diferente.
 Cada archivo se compone de un conjunto de funciones denotando cada una
 un unit test más una función que provee la biblioteca Boost Test, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+init_unit_test_suite+
\end_layout

\end_inset

, en la cual se listan los tests a ejecutar.
 Estos archivos luego se compilan en ejecutables.
 Al ejecutarlos se ejecutan los tests listados en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+init_unit_test_suite+
\end_layout

\end_inset

.
 Las aserciones las realizamos utilizando la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+BOOST_CHECK+
\end_layout

\end_inset

.
 A modo ilustrativo vamos a ver una parte del archivo apply_tarjan_test.cpp
 que corresponde al unit test de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

#include <boost/test/unit_test.hpp>
\end_layout

\begin_layout Plain Layout

#include <boost/test/included/unit_test.hpp>
\end_layout

\begin_layout Plain Layout

#include <causalize/apply_tarjan.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace boost::unit_test;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void apply_tarjan_test() {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   BOOST_CHECK(apply_tarjan(graph, components) == 4);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test_suite* init_unit_test_suite( int, char* [] ) {
\end_layout

\begin_layout Plain Layout

    framework::master_test_suite().p_name.value = "Apply Tarjan";
\end_layout

\begin_layout Plain Layout

    framework::master_test_suite().add( BOOST_TEST_CASE( &apply_tarjan_test
 ));
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta porción de código podemos ver la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan_test()+
\end_layout

\end_inset

 la cual constituye el unit test.
 También podemos ver la declaración de la función donde se agrega el test
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan_test+
\end_layout

\end_inset

 al test suite.
 Al ejecutar el test la salida es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    $ ./apply_tarjan_test
\end_layout

\begin_layout Plain Layout

    Running 1 test case...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    *** No errors detected 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Escribimos unit tests para los siguientes componentes:
\end_layout

\begin_layout Itemize
La función process_for_equations (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expansión-de-ecuaciones"

\end_inset

).
\end_layout

\begin_layout Itemize
La función apply_tarjan (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

).
\end_layout

\begin_layout Itemize
La clase Causalization Strategy (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Optimización"

\end_inset

).
\end_layout

\begin_layout Itemize
La clase clase EvalExp (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:EvalExp"

\end_inset

)
\end_layout

\begin_layout Standard
A continuación vamos a describir cada uno de los unit tests.
\end_layout

\begin_layout Section
process_for_equation_test
\end_layout

\begin_layout Section
apply_tarjan_test
\end_layout

\begin_layout Standard
Para realizar el test de la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

, descripta en la sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

, construimos un grafo de causalización sencillo, al cual le 
\begin_inset Quotes eld
\end_inset

fabricamos
\begin_inset Quotes erd
\end_inset

 un bucle.
 El grafo que creamos es un grafo con 10 vértices y 11 aristas.
 La declaración del grafo se puede ver a continuación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  CausalizationGraph graph;
\end_layout

\begin_layout Plain Layout

  VertexProperties vp1;
\end_layout

\begin_layout Plain Layout

  vp1.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e1 = add_vertex(vp1, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp2;
\end_layout

\begin_layout Plain Layout

  vp2.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u1 = add_vertex(vp2, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp3;
\end_layout

\begin_layout Plain Layout

  vp3.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e2 = add_vertex(vp3, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp4;
\end_layout

\begin_layout Plain Layout

  vp4.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u2 = add_vertex(vp4, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp5;
\end_layout

\begin_layout Plain Layout

  vp5.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e3 = add_vertex(vp5, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp6;
\end_layout

\begin_layout Plain Layout

  vp6.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u3 = add_vertex(vp6, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp7;
\end_layout

\begin_layout Plain Layout

  vp7.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e4 = add_vertex(vp7, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp8;
\end_layout

\begin_layout Plain Layout

  vp8.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u4 = add_vertex(vp8, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp9;
\end_layout

\begin_layout Plain Layout

  vp9.type = E;
\end_layout

\begin_layout Plain Layout

  Vertex e5 = add_vertex(vp9, graph);
\end_layout

\begin_layout Plain Layout

  VertexProperties vp10;
\end_layout

\begin_layout Plain Layout

  vp10.type = U;
\end_layout

\begin_layout Plain Layout

  Vertex u5 = add_vertex(vp10, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e1, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e1, u4, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e2, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e4, u1, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e4, u2, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u1, graph);
\end_layout

\begin_layout Plain Layout

  // The following edges  form a cycle.
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e3, u5, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u3, graph);
\end_layout

\begin_layout Plain Layout

  add_edge(e5, u5, graph);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las últimas 4 aristas forman el único bucle del grafo.
\end_layout

\begin_layout Standard
El algoritmo de tarjan se aplica sobre un grafo dirigido que resulta de
 aplicar los pasos descriptos en 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Aplicación-Tarjan-Boost"

\end_inset

 a un grafo no dirigido.
 Para el caso del grafo utilizado en este test el grafo dirigido resultante
 es un grafo de 5 vértices con un bucle.
 Por lo tanto el algoritmo de tarjan debe encontrar 4 componentes fuertemente
 conexos.
 Esta aserción es la que utilizamos para probar nuestra función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb+apply_tarjan+
\end_layout

\end_inset

 y lo hacemos de la siguiente manera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

  std::map<int, causalize::Component> components;
\end_layout

\begin_layout Plain Layout

  BOOST_CHECK(apply_tarjan(graph, components) == 4);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Conclusiones
\end_layout

\begin_layout Section
Conclusiones generales
\end_layout

\begin_layout Section
Trabajo a futuro
\end_layout

\begin_layout Itemize
Singularidades estructurales
\end_layout

\begin_layout Itemize
Tearing
\end_layout

\begin_layout Itemize
Causalización de ecuaciones for sin expanción
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
